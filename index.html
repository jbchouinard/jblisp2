<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="None">
  
  <link rel="canonical" href="https://jbchouinard.github.io/jibi/">
  <link rel="shortcut icon" href="img/favicon.ico">
  <title>Jibi Scheme</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Language Reference";
    var mkdocs_page_input_path = "index.md";
    var mkdocs_page_url = "/jibi/";
  </script>
  
  <script src="js/jquery-2.1.1.min.js" defer></script>
  <script src="js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="." class="icon icon-home"> Jibi Scheme</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="./search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href=".">Language Reference</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#types">Types</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#primitive-types">Primitive Types</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#string">string</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#symbol">symbol</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#integer">integer</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#float">float</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#bool">bool</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#nil">nil</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#composite-types">Composite Types</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#pair">pair</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#list">list</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#special-types">Special Types</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#quote">quote</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#error">error</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#callable-types">Callable Types</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#lambda">lambda</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#procmacro">procmacro</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#builtin-callable-types">Builtin Callable Types</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#function">function</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#specialform">specialform</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#forms">Forms</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#binding-and-assignment">Binding and Assignment</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#def">def</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#set">set!</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#let">let</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#defglobal">defglobal</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#setglobal">setglobal!</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#function-definition">Function Definition</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#defn">defn</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#fn">fn</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#control-flow">Control Flow</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#begin">begin</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#if">if</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cond">cond</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#or">or</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#and">and</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#comparison">Comparison</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#eq">eq?</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#equal">equal?</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#logical-operators">Logical Operators</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#not">not</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#any">any</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#all">all</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#pair-and-list-operations">Pair and List Operations</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#cons">cons</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#car">car</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cdr">cdr</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#list_1">list</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#lcons">lcons</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#nth">nth</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#empty">empty?</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#list_2">list?</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#map">map</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#fold">fold</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#range">range</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#string-operations">String Operations</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#len">len</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#concat">concat</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#replace">replace</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#substring">substring</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#split">split</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#contains">contains?</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#left-pad">left-pad</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#numerical-operations">Numerical Operations</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#add">Add: +</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#sub-">Sub: -</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#mul">Mul: *</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#div">Div: /</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#numeric-comparison">Numeric Comparison: =, >, >=, \&lt;, \&lt;=</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#type-conversions">Type Conversions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#string_1">string</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#integer_1">integer</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#float_1">float</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#printing">Printing</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#print">print</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#repr">repr</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#display">display</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#modules">Modules</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#import">import</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#use">use</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#import-from">import-from</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#type-inspection">Type Inspection</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#type">type</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#type_1">type?</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#quoting-and-evaluation">Quoting and Evaluation</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#quote_1">quote</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#eval">eval</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#evalfile">evalfile</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#apply">apply</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#macro-definition">Macro Definition</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#defmacro">defmacro</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#macro">macro</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exceptions">Exceptions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#error_1">error</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#exception">exception</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#raise">raise</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#try">try</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#assert">assert</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#environment-procedures">Environment Procedures</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#env">env</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#env-lookup">env-lookup</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#env-def">env-def</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#env-set">env-set</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#env-parent">env-parent</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#env-globals">env-globals</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#system-procedures">System Procedures</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#getenv">getenv</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#exit">exit</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#debugging">Debugging</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#dd">dd</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ddp">ddp</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#dda">dda</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ddc">ddc</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ddm">ddm</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#standard-library-stl">Standard Library (STL)</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#stlmath">stl/math</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#sign">sign</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#abs">abs</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#remainder">remainder</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#pow">pow</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#sum">sum</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#product">product</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#min">min</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#max">max</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#even">even?</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#odd">odd?</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#factorial">factorial</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#stldecimal">stl/decimal</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#decimal">decimal</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#round">round</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#set-precision">set-precision</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#coef">coef</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#expn">expn</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#stlunittest">stl/unittest</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#test">test</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#test-suite">test-suite</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#assert-not">assert-not</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#assert-eq">assert-eq</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#assert-equal">assert-equal</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#assert-type">assert-type</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#assert-raise">assert-raise</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="" href="/jibi/Jibi Scheme Manual.pdf">Dowload PDF</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="" href="/jibi/crate/jibi/index.html">Crate Documentation</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="" href="https://github.com/jbchouinard/jibi">GitHub Repo</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href=".">Jibi Scheme</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".">Docs</a> &raquo;</li>
    
      
    
    <li>Language Reference</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h1 id="jibi-scheme">Jibi Scheme</h1>
<p><strong>version 0.1.6</strong></p>
<h2 id="overview">Overview</h2>
<p>A homebrew interpreted, non-RnRS compliant dialect of Scheme.</p>
<h2 id="types">Types</h2>
<h3 id="primitive-types">Primitive Types</h3>
<h4 id="string">string</h4>
<pre><code class="language-nohighlight">&quot;some-string&quot;
</code></pre>
<p>String are immutable.</p>
<p><em>Evaluation Rule:</em> A <code>string</code> value evaluates to itself.</p>
<hr />
<h4 id="symbol">symbol</h4>
<pre><code class="language-nohighlight">some-symbol
</code></pre>
<p>All <code>symbol</code> values are interned, therefore
<code>(eq? 'some-symbol 'some-symbol)</code> is true.</p>
<p><em>Evaluation Rule:</em> <code>symbol</code> values are variable names. When evaluated, a
<code>symbol</code> is replaced by the value of its binding in the nearest
enclosing scope where it is defined. An error is raised if <code>symbol</code> is
not bound in any enclosing scope.</p>
<hr />
<h4 id="integer">integer</h4>
<pre><code class="language-nohighlight">100
</code></pre>
<p>The underlying type for <code>integer</code> is <code>i128</code>. Integer overflow raises an
exception.</p>
<p><em>Evaluation Rule:</em> An <code>integer</code> value evaluates to itself.</p>
<hr />
<h4 id="float">float</h4>
<pre><code class="language-nohighlight">1.5
</code></pre>
<p>The underlying type for <code>float</code> is <code>f64</code>.</p>
<p><em>Evaluation Rule:</em> A <code>float</code> value evaluates to itself.</p>
<hr />
<h4 id="bool">bool</h4>
<pre><code class="language-nohighlight">true
false
</code></pre>
<p>Only <code>bool</code> have truth values, therefore they are the only type that can
be used as predicates, e.g. for <code>if</code>.</p>
<p><em>Evaluation Rule:</em> A <code>bool</code> value evaluates to itself.</p>
<hr />
<h4 id="nil">nil</h4>
<pre><code class="language-nohighlight">nil
</code></pre>
<p>In Jibi Scheme, <code>nil</code> and all empty lists <code>()</code> are the same object,
therefore <code>(eq? () ())</code> is true.</p>
<p><em>Evaluation Rule:</em> <code>nil</code> evaluates to itself.</p>
<hr />
<h3 id="composite-types">Composite Types</h3>
<h4 id="pair">pair</h4>
<pre><code class="language-nohighlight">(cons :expr :expr)
</code></pre>
<p>The <code>pair</code>, also known as cons cell, is the basic Scheme compound data
type. It is simply a grouping of two values of any types (2-tuple); the
first and second values are sometimes referred to respectively as the
<code>car</code> and <code>cdr</code>.</p>
<p><em>Evaluation Rule:</em> <code>pair</code> values are evaluated by procedure application,
however, only <code>pair</code> values which are <code>list</code>’s can be properly applied;
evaluating a non-list <code>pair</code> raises an error.</p>
<hr />
<h4 id="list">list</h4>
<pre><code class="language-nohighlight">; code
(:callable :expr ...)
; data
()
(cons :expr (cons ()))
(list :expr ...)
</code></pre>
<p>A <code>list</code> value is either the empty list <code>()</code>, or ordered <code>pair</code>’s
terminated by <code>()</code>, where the <code>car</code> of the <code>pair</code> is an element of the
list, and the <code>cdr</code> is the rest of the list.</p>
<p>Scheme data and code are both represented as lists, which makes
meta-programming easy and fun. See <a href="#quoting-and-evaluation">Quoting and
Evaluation</a> and <a href="#macro-definition">Macro
Definition</a>.</p>
<p><em>Evaluation Rule:</em> The first value of the list is applied (called) with
the rest of the list as arguments. If the first value of the list is not
<a href="#callable-types"><code>callable</code></a>, an error is raised. Exception: the empty
list <code>()</code> is not applied, it evaluates to itself. See <a href="#function-definition">Function
Definition</a>.</p>
<hr />
<h3 id="special-types">Special Types</h3>
<h4 id="quote">quote</h4>
<pre><code class="language-nohighlight">(quote :expr)
'expr
</code></pre>
<p>Any expression can be quoted, using either the <code>quote</code> form or a
starting apostrophe <code>'</code>.</p>
<p><em>Evaluation Rule:</em> A quoted expression evaluates to the expression. This
is useful to prevent <code>symbol</code> binding and procedure application. See
<a href="#quoting-and-evaluation">Quoting and Evaluation</a>.</p>
<hr />
<h4 id="error">error</h4>
<pre><code class="language-nohighlight">(error type &quot;some-message&quot;)
</code></pre>
<p>Error values do no inherently do anything, until they are
<a href="#raise"><code>raise</code></a>’d as exceptions. See <a href="#exceptions">Exceptions</a>.</p>
<p><em>Evaluation Rule:</em> An <code>error</code> value evaluates to itself.</p>
<hr />
<h3 id="callable-types">Callable Types</h3>
<h4 id="lambda">lambda</h4>
<pre><code class="language-nohighlight">(fn params :expr ...)
</code></pre>
<p>See <a href="#function-definition">Function Definition</a>.</p>
<p><em>Evaluation Rule:</em> A <code>lambda</code> value evaluates to itself. It is applied
when it is the first element of a <code>list</code>.</p>
<hr />
<h4 id="procmacro">procmacro</h4>
<pre><code class="language-nohighlight">(macro params :expr ...)
</code></pre>
<p>Procedural macros. See <a href="#macro-definition">Macro Definition</a>.</p>
<p><em>Evaluation Rule:</em> A <code>procmacro</code> value evaluates to itself. It is
applied when it is the first element of a <code>list</code>.</p>
<hr />
<h3 id="builtin-callable-types">Builtin Callable Types</h3>
<h4 id="function">function</h4>
<pre><code class="language-nohighlight">; not constructable
</code></pre>
<p>Opaque type containing a builtin function.</p>
<p><em>Evaluation Rule:</em> A <code>function</code> value evaluates to itself. It is applied
when it is the first element of a <code>list</code>.</p>
<hr />
<h4 id="specialform">specialform</h4>
<pre><code class="language-nohighlight">; not constructable
</code></pre>
<p>Opaque type containing a builtin macro.</p>
<p><em>Evaluation Rule:</em> A <code>specialform</code> value evaluates to itself. It is
applied when it is the first element of a <code>list</code>.</p>
<hr />
<h2 id="forms">Forms</h2>
<h3 id="binding-and-assignment">Binding and Assignment</h3>
<h4 id="def">def</h4>
<pre><code class="language-nohighlight">(def name :expr)
</code></pre>
<p>Create and assign binding in local scope.</p>
<hr />
<h4 id="set">set!</h4>
<pre><code class="language-nohighlight">(set! name :expr)
</code></pre>
<p>Change existing binding. Raises error if a binding does not already
exists.</p>
<hr />
<h4 id="let">let</h4>
<pre><code class="language-nohighlight">(lets ((name value:expr) ...) :expr ...)
</code></pre>
<p>Create bindings in a new local scopes.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (let ((x 5) (y 7))
...    (display x)
...    (display y))
5
7
</code></pre>
<hr />
<h4 id="defglobal">defglobal</h4>
<pre><code class="language-nohighlight">(defglobal name :expr)
</code></pre>
<p>Create and assign binding in global env.</p>
<hr />
<h4 id="setglobal">setglobal!</h4>
<pre><code class="language-nohighlight">(setglobal! name :expr)
</code></pre>
<p>Change existing binding in global env. Raises error if a binding does
not already exists.</p>
<hr />
<h3 id="function-definition">Function Definition</h3>
<h4 id="defn">defn</h4>
<pre><code class="language-nohighlight">(defn name parameters :expr ...)
</code></pre>
<p>Create lambda function and bind it to <code>name</code>.</p>
<p>Variadic lambdas can be defined with formal parameters like <code>(x . xs)</code> -
there must be a single parameter after <code>.</code>, which will be a list
containing zero or more arguments depending on the number of arguments
passed.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (defn increment (x) (+ x 1))
&gt;&gt;&gt; (increment 1)
2
&gt;&gt;&gt; (defn variadic (x y . rest) rest)
&gt;&gt;&gt; (variadic 1)
Unhandled ApplyError &quot;expected at least 2 argument(s)&quot;
&gt;&gt;&gt; (variadic 1 2)
()
&gt;&gt;&gt; (variadic 1 2 3 4)
(3 4)
</code></pre>
<hr />
<h4 id="fn">fn</h4>
<pre><code class="language-nohighlight">(fn parameters :expr ...)
</code></pre>
<p>Create a lambda (function). See <a href="#defn"><code>defn</code></a>.</p>
<hr />
<h3 id="control-flow">Control Flow</h3>
<h4 id="begin">begin</h4>
<pre><code class="language-nohighlight">(begin :expr ...)
</code></pre>
<p>Evaluate expressions sequentially and return value of last expression.</p>
<hr />
<h4 id="if">if</h4>
<pre><code class="language-nohighlight">(if predicate:bool then:expr else:expr)
</code></pre>
<p>Evaluates only <code>then</code> or <code>else</code> conditonally on the value of
<code>predicate</code>.</p>
<hr />
<h4 id="cond">cond</h4>
<pre><code class="language-nohighlight">(cond (predicate:bool :expr ...) ...)
</code></pre>
<p>Evaluates body of the first clause which has a true predicate.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (cond
...   (false (assert false))
...   ((not true) (assert false))
...   (else (print &quot;foo&quot;) (print &quot;bar&quot;)))
foo
bar
</code></pre>
<hr />
<h4 id="or">or</h4>
<pre><code class="language-nohighlight">(or expr expr)
</code></pre>
<p>Logical or. Short-circuiting; if the first expression evaluates to true,
the second expression is not evaluated.</p>
<hr />
<h4 id="and">and</h4>
<pre><code class="language-nohighlight">(and expr expr)
</code></pre>
<p>Logical and. Short-circuiting; if the first expression evaluates to
false, the second expression is not evaluated.</p>
<hr />
<h3 id="comparison">Comparison</h3>
<h4 id="eq">eq?</h4>
<pre><code class="language-nohighlight">(eq? :expr :expr)
</code></pre>
<p>Identity comparison. Check if two values are the same object.</p>
<hr />
<h4 id="equal">equal?</h4>
<pre><code class="language-nohighlight">(equal? :expr :expr)
</code></pre>
<p>Value comparison. Check if two values are equal.</p>
<hr />
<h3 id="logical-operators">Logical Operators</h3>
<h4 id="not">not</h4>
<pre><code class="language-nohighlight">(not :bool)
</code></pre>
<p>Logical not.</p>
<hr />
<h4 id="any">any</h4>
<pre><code class="language-nohighlight">(any :bool ...)
</code></pre>
<p>Returns true if any argument is true.</p>
<hr />
<h4 id="all">all</h4>
<pre><code class="language-nohighlight">(all :bool ..)
</code></pre>
<p>Returns true if all arguments are true.</p>
<hr />
<h3 id="pair-and-list-operations">Pair and List Operations</h3>
<h4 id="cons">cons</h4>
<pre><code class="language-nohighlight">(cons left:expr right:expr)
</code></pre>
<p>Construct a pair.</p>
<hr />
<h4 id="car">car</h4>
<pre><code class="language-nohighlight">(car :pair)
</code></pre>
<p>Get first item of a pair (head of list).</p>
<hr />
<h4 id="cdr">cdr</h4>
<pre><code class="language-nohighlight">(cdr :pair)
</code></pre>
<p>Get second item of a pair (rest of list).</p>
<hr />
<h4 id="list_1">list</h4>
<pre><code class="language-nohighlight">(list :expr ...)
</code></pre>
<p>Construct a list, which is a linked list made from pairs and terminated
by <code>nil</code>.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (equal? (list 1 2 3) (cons 1 (cons 2 (cons 3 nil))))
true
&gt;&gt;&gt; (equal? (list 1 2 3) (cons 1 (list 2 3)))
true
</code></pre>
<hr />
<h4 id="lcons">lcons</h4>
<pre><code class="language-nohighlight">(lcons :expr ... :list)
</code></pre>
<p>Prepend values to a list.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (lcons 1 2 3 (list 4 5))
(1 2 3 4 5)
</code></pre>
<hr />
<h4 id="nth">nth</h4>
<pre><code class="language-nohighlight">(nth :integer :list)
</code></pre>
<p>Get nth item from a list (zero-indexed).</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (nth 3 (list 0 1 2 3 4))
3
</code></pre>
<hr />
<h4 id="empty">empty?</h4>
<pre><code class="language-nohighlight">(empty? :expr)
</code></pre>
<p>Check if value is the empty list (nil).</p>
<hr />
<h4 id="list_2">list?</h4>
<pre><code class="language-nohighlight">(list? :expr)
</code></pre>
<p>Check if value is a nil-terminated list of ordered pairs.</p>
<hr />
<h4 id="map">map</h4>
<pre><code class="language-nohighlight">(map f:procedure vals:list)
</code></pre>
<p>Applies <code>f</code> to each value in a list and return results in list.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (map (fn (x) (* 2 x)) (list 1 2 3))
(2 4 6)
</code></pre>
<hr />
<h4 id="fold">fold</h4>
<pre><code class="language-nohighlight">(fold f:procedure init:expr vals:list)
</code></pre>
<p>Applies <code>f</code> to each value in a list and accumulate results in <code>init</code>.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (fold + 0 (list 1 2 3))
6
&gt;&gt;&gt; (fold cons () (list 1 2 3))
(3 2 1)
</code></pre>
<hr />
<h4 id="range">range</h4>
<pre><code class="language-nohighlight">(range from:number to:number [step:number])
</code></pre>
<p>Produce list of numbers for range [<code>from</code>, <code>to</code>], with an optional
step size.</p>
<hr />
<h3 id="string-operations">String Operations</h3>
<h4 id="len">len</h4>
<pre><code class="language-nohighlight">(len :string)
</code></pre>
<p>Get length of string (number of UTF-8 scalar values).</p>
<hr />
<h4 id="concat">concat</h4>
<pre><code class="language-nohighlight">(concat :string ...)
</code></pre>
<p>Concatenate multiple strings.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (concat &quot;foo&quot; &quot;bar&quot; &quot;baz&quot;)
&quot;foobarbaz&quot;
</code></pre>
<hr />
<h4 id="replace">replace</h4>
<pre><code class="language-nohighlight">(replace :string :string :string)
</code></pre>
<p>Description.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (replace &quot;fuzzy bears are fuzzy&quot; &quot;fuzzy&quot; &quot;long&quot;)
&quot;long bears are long&quot;
</code></pre>
<hr />
<h4 id="substring">substring</h4>
<pre><code class="language-nohighlight">(substring :string start:integer end:integer)
</code></pre>
<p>Get a substring. Negative indices count from the end of the string. If
start > end, the substring is reversed.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (substring &quot;foobar&quot; 1 -1)
&quot;ooba&quot;
&gt;&gt;&gt; (substring &quot;foobar&quot; 6 0)
&quot;raboof&quot;
</code></pre>
<hr />
<h4 id="split">split</h4>
<pre><code class="language-nohighlight">(split :string separator:string)
</code></pre>
<p>Split a string by separator.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (split &quot;12.34.56&quot; &quot;.&quot;)
(&quot;12&quot; &quot;34&quot; &quot;56&quot;)
</code></pre>
<hr />
<h4 id="contains">contains?</h4>
<pre><code class="language-nohighlight">(contains? str:string substr:string)
</code></pre>
<p>Check if <code>str</code> contains <code>substr</code>.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (contains? &quot;foobar&quot; &quot;foo&quot;)
true
</code></pre>
<hr />
<h4 id="left-pad">left-pad</h4>
<pre><code class="language-nohighlight">(left-pad string:string char:string width:integer)
</code></pre>
<p>Pad string to <code>width</code> characters.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (left-pad &quot;34&quot; &quot;0&quot; 4)
0034
</code></pre>
<hr />
<h3 id="numerical-operations">Numerical Operations</h3>
<p>If different number types are mixed, integers get promoted to floats
(may raise an error if the integer is too large or small to be
represented as a float).</p>
<h4 id="add">Add: +</h4>
<pre><code class="language-nohighlight">(+ :number ...)
</code></pre>
<p>Addition.</p>
<h4 id="sub-">Sub: -</h4>
<pre><code class="language-nohighlight">(- :number ...)
</code></pre>
<p>Negation (single argument) or substraction (multiple arguments).</p>
<h4 id="mul">Mul: *</h4>
<pre><code class="language-nohighlight">(* :number ...)
</code></pre>
<p>Multiplication.</p>
<h4 id="div">Div: /</h4>
<pre><code class="language-nohighlight">(/ :number ...)
</code></pre>
<p>Reciprocal (single argument) or division (multiple arguments).</p>
<hr />
<h4 id="numeric-comparison">Numeric Comparison: =, >, >=, \&lt;, \&lt;=</h4>
<pre><code class="language-nohighlight">(= :number :number)
(&gt; :number :number)
(&gt;= :number :number)
(&lt; :number :number)
(&lt;= :number :number)
</code></pre>
<p>Compare numerical values.</p>
<hr />
<h3 id="type-conversions">Type Conversions</h3>
<h4 id="string_1">string</h4>
<pre><code class="language-nohighlight">(string :expr)
</code></pre>
<p>Convert value to string.</p>
<hr />
<h4 id="integer_1">integer</h4>
<pre><code class="language-nohighlight">(integer :float|:string)
</code></pre>
<p>Convert value to integer.</p>
<hr />
<h4 id="float_1">float</h4>
<pre><code class="language-nohighlight">(float :integer|:string)
</code></pre>
<p>Convert value to float.</p>
<hr />
<h3 id="printing">Printing</h3>
<h4 id="print">print</h4>
<pre><code class="language-nohighlight">(print :string)
</code></pre>
<p>Print a string.</p>
<hr />
<h4 id="repr">repr</h4>
<pre><code class="language-nohighlight">(repr :expr)
</code></pre>
<p>Get string representation of a value.</p>
<hr />
<h4 id="display">display</h4>
<pre><code class="language-nohighlight">(display :expr)
</code></pre>
<p>Print string representation of a value.</p>
<hr />
<h3 id="modules">Modules</h3>
<p><code>jibi</code> has a basic namespaced module system. A module is simply a
<code>.jibi</code> file.</p>
<p>They provide no privacy, all variables defined in the module scope are
accessible to importers.</p>
<p>Module files are only evaluated once, re-importing gets a reference to
the existing module.</p>
<p>At the moment only the current working directory is searched to find
modules, thus importing “stl/unittest” looks for the file
<code>./stl/unittest.jibi'.</code></p>
<h4 id="import">import</h4>
<pre><code class="language-nohighlight">(import module:string as name)
</code></pre>
<p>Import module and bind it to <code>name</code>.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (import &quot;stl/math&quot; as math)
&gt;&gt;&gt; (math::product (list 2 3 4))
24
</code></pre>
<hr />
<h4 id="use">use</h4>
<pre><code class="language-nohighlight">(use module:symbol name ...)
</code></pre>
<p>Bind a name from a module into the global scope.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (import &quot;stl/math&quot; as math)
&gt;&gt;&gt; (use math product sum)
&gt;&gt;&gt; (product (list 2 3 4))
24
</code></pre>
<hr />
<h4 id="import-from">import-from</h4>
<pre><code class="language-nohighlight">(import-from module:string name ...)
</code></pre>
<p>Import specific names from a module.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (import-from &quot;stl/math&quot; product sum)
&gt;&gt;&gt; (sum (list 2 3 4))
9
&gt;&gt;&gt; (product (list 2 3 4))
24
</code></pre>
<hr />
<h3 id="type-inspection">Type Inspection</h3>
<h4 id="type">type</h4>
<pre><code class="language-nohighlight">(type :expr)
</code></pre>
<p>Inspect type of a value.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (type &quot;foo&quot;)
string
</code></pre>
<hr />
<h4 id="type_1">type?</h4>
<pre><code class="language-nohighlight">(type? :expr type)
(string? :expr)
(symbol? :expr)
...
</code></pre>
<p>Test type of a value. There are also convenience functions for every
type.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (type? &quot;foo&quot; string)
true
&gt;&gt;&gt; (integer? &quot;foo&quot;)
false
</code></pre>
<hr />
<h3 id="quoting-and-evaluation">Quoting and Evaluation</h3>
<h4 id="quote_1">quote</h4>
<pre><code class="language-nohighlight">(quote :expr)
</code></pre>
<p>A quoted expression evaluates to the expression.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (def a 100)
&gt;&gt;&gt; a
100
&gt;&gt;&gt; (quote a)
a
&gt;&gt;&gt; (+ 5 5)
10
&gt;&gt;&gt; (quote (+ 5 5))
(+ 5 5)
</code></pre>
<hr />
<h4 id="eval">eval</h4>
<pre><code class="language-nohighlight">(eval :expr)
</code></pre>
<p>Evaluate an expression.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (def expr (quote (+ 5 5)))
&gt;&gt;&gt; expr
(+ 5 5)
&gt;&gt;&gt; (eval expr)
10
</code></pre>
<hr />
<h4 id="evalfile">evalfile</h4>
<pre><code class="language-nohighlight">(evalfile filename:string)
</code></pre>
<p>Evaluate file in the global environment.</p>
<hr />
<h4 id="apply">apply</h4>
<pre><code class="language-nohighlight">(apply :procedure :list)
</code></pre>
<p>Apply a procedure to a list of arguments.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (apply + (list 1 2 3))
6
</code></pre>
<hr />
<h3 id="macro-definition">Macro Definition</h3>
<h4 id="defmacro">defmacro</h4>
<pre><code class="language-nohighlight">(defmacro name formals :expr ...)
</code></pre>
<p>jibi macros are “procedural”; they are simply lambdas which return code.</p>
<p>The body of the macro is first evaluated in the macro’s lexical
environment. Then the resulting expression is evaluated in the caller’s
environment.</p>
<p>Beware of capturing variables from the macro’s environment; if you want
to refer to variables in the invocation environment, use quotation.</p>
<p>This <code>add-x</code> macro captures the global binding for <code>x</code>:</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; (defmacro add-x (y) (list + x y))
&gt;&gt;&gt; (def x 100)
&gt;&gt;&gt; (add-x 5)
105
&gt;&gt;&gt; (set! x 200)
&gt;&gt;&gt; (add-x 5)
205
&gt;&gt;&gt; ((fn (x) (add-x 5)) 1000)
205
</code></pre>
<p>In this version, <code>x</code> is not captured; the value of <code>x</code> is taken from the
local scope where the macro is called:</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; (def x 100)
&gt;&gt;&gt; (defmacro add-x (y) (list + 'x y))
&gt;&gt;&gt; ((fn (x) (add-x 5)) 1000)
1005
</code></pre>
<hr />
<h4 id="macro">macro</h4>
<pre><code class="language-nohighlight">(macro formals :expr ...)
</code></pre>
<p>Create macro. See <a href="#defmacro">‘defmacro’</a>.</p>
<hr />
<h3 id="exceptions">Exceptions</h3>
<p>Errors can be raised to interrupt program flow, and can be caught with
the <code>try</code> form.</p>
<h4 id="error_1">error</h4>
<pre><code class="language-nohighlight">(error type:symbol reason:string)
</code></pre>
<p>Create error with custom type.</p>
<h4 id="exception">exception</h4>
<pre><code class="language-nohighlight">(exception reason:string)
</code></pre>
<p>Create error of type Exception.</p>
<h4 id="raise">raise</h4>
<pre><code class="language-nohighlight">(raise :error)
</code></pre>
<p>Raise an error (can be any error type, not just Exception).</p>
<h4 id="try">try</h4>
<pre><code class="language-nohighlight">(try body:expr catch:expr)
</code></pre>
<p>Try evaluating <code>body</code>. If an error is raised, evaluate <code>catch</code>; the
raised error value is bound to <code>err</code> when <code>catch</code> is evaluated.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (defn errored ()
...     (raise (exception &quot;oh no!&quot;))
...     (print &quot;never evaluated&quot;))
&gt;&gt;&gt; (errored)
Unhandled Error: oh no!
&gt;&gt;&gt; (try (print &quot;no error&quot;) (print (concat &quot;handled &quot; (repr err))))
no error
&gt;&gt;&gt; (try (errored) (print (concat &quot;handled &quot; (repr err))))
handled #[error Exception &quot;oh no!&quot;]
</code></pre>
<hr />
<h4 id="assert">assert</h4>
<pre><code class="language-nohighlight">(assert predicate:bool)
</code></pre>
<p>Raises an exception if <code>predicate</code> is false.</p>
<hr />
<h3 id="environment-procedures">Environment Procedures</h3>
<h4 id="env">env</h4>
<pre><code class="language-nohighlight">(env)
</code></pre>
<p>Get the nearest enclosing environment (most local scope).</p>
<hr />
<h4 id="env-lookup">env-lookup</h4>
<pre><code class="language-nohighlight">(env-lookup :env :symbol)
</code></pre>
<p>Look up symbol in the given environment.</p>
<hr />
<h4 id="env-def">env-def</h4>
<pre><code class="language-nohighlight">(env-def :env :symbol :expr)
</code></pre>
<p>Define symbol in the given environment.</p>
<hr />
<h4 id="env-set">env-set</h4>
<pre><code class="language-nohighlight">(env-set! :env :symbol :expr)
</code></pre>
<p>Set symbol in the given environment.</p>
<hr />
<h4 id="env-parent">env-parent</h4>
<pre><code class="language-nohighlight">(env-parent :env)
</code></pre>
<p>Get parent env, or <code>nil</code> if there is no parent env.</p>
<hr />
<h4 id="env-globals">env-globals</h4>
<pre><code class="language-nohighlight">(env-globals)
</code></pre>
<p>Get the global environment.</p>
<hr />
<h3 id="system-procedures">System Procedures</h3>
<h4 id="getenv">getenv</h4>
<pre><code class="language-nohighlight">(getenv var:string)
</code></pre>
<p>Get value of environment variable. Raises exception if the variable is
not set or contains non-UTF8 characters.</p>
<hr />
<h4 id="exit">exit</h4>
<pre><code class="language-nohighlight">(exit :integer)
</code></pre>
<p>Exit program with a status code.</p>
<hr />
<h3 id="debugging">Debugging</h3>
<h4 id="dd">dd</h4>
<pre><code class="language-nohighlight">(dd :expr)
</code></pre>
<p>Print Rust struct debug.</p>
<hr />
<h4 id="ddp">ddp</h4>
<pre><code class="language-nohighlight">(ddp :expr)
</code></pre>
<p>Pretty print Rust struct debug.</p>
<hr />
<h4 id="dda">dda</h4>
<pre><code class="language-nohighlight">(dda :expr)
</code></pre>
<p>Print pointer address.</p>
<hr />
<h4 id="ddc">ddc</h4>
<pre><code class="language-nohighlight">(ddc :lambda|:procmacro)
</code></pre>
<p>Print code of (non-builtin) lambda or macro.</p>
<hr />
<h4 id="ddm">ddm</h4>
<pre><code class="language-nohighlight">(ddm :procmacro :expr ...)
</code></pre>
<p>Print code generated by a <code>procmacro</code> for the given arguments.</p>
<hr />
<h2 id="standard-library-stl">Standard Library (STL)</h2>
<p>I hope you were not expecting a real standard library. You can have some
unit testing and maths as consolation.</p>
<h3 id="stlmath">stl/math</h3>
<p>Some mathematical functions.</p>
<h4 id="sign">sign</h4>
<pre><code class="language-nohighlight">(sign :number)
</code></pre>
<p>Returns sign of number.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (sign -12)
-1
&gt;&gt;&gt; (sign 100)
1
&gt;&gt;&gt; (sign 0)
0
</code></pre>
<hr />
<h4 id="abs">abs</h4>
<pre><code class="language-nohighlight">(abs :number)
</code></pre>
<p>Returns absolute value of number</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (abs -12)
12
</code></pre>
<hr />
<h4 id="remainder">remainder</h4>
<pre><code class="language-nohighlight">(remainder :number :number)
</code></pre>
<p>Returns the least positive remainder for integer floor division.
(Returns zero for floating point division, or very close to zero,
because of floating point errors.)</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (remainder 42 5)
2
&gt;&gt; (remainder 42 -5)
2
</code></pre>
<hr />
<h4 id="pow">pow</h4>
<pre><code class="language-nohighlight">(pow base:number exponent:number)
</code></pre>
<p>Perform exponentiation.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (pow 10 3)
1000
&gt;&gt;&gt; (pow 2 10)
1024
</code></pre>
<hr />
<h4 id="sum">sum</h4>
<pre><code class="language-nohighlight">(sum :list)
</code></pre>
<p>Returns sum of list.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (sum (list 1 2 3 4))
10
</code></pre>
<hr />
<h4 id="product">product</h4>
<pre><code class="language-nohighlight">(product :list)
</code></pre>
<p>Returns product of list.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (product (list 1 2 3 4))
24
</code></pre>
<hr />
<h4 id="min">min</h4>
<pre><code class="language-nohighlight">(min :number :number)
</code></pre>
<p>Returns smallest of 2 values.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (fold min INTMAX (list 21 321 421 -12))
421
</code></pre>
<hr />
<h4 id="max">max</h4>
<pre><code class="language-nohighlight">(max :number :number)
</code></pre>
<p>Returns largest of 2 values.</p>
<hr />
<h4 id="even">even?</h4>
<pre><code class="language-nohighlight">(even? :number)
</code></pre>
<p>Check if even.</p>
<hr />
<h4 id="odd">odd?</h4>
<pre><code class="language-nohighlight">(odd? :number)
</code></pre>
<p>Check if odd.</p>
<hr />
<h4 id="factorial">factorial</h4>
<pre><code class="language-nohighlight">(factorial :number)
</code></pre>
<p>Compute factorial.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (factorial 4)
24
</code></pre>
<hr />
<h3 id="stldecimal">stl/decimal</h3>
<p>The <code>decimal</code> module implements floating point decimal arithmetic.</p>
<p>By default, multiplication and division produce results with a maximum
precision of 10 decimal places. This can be changed with
<code>set-precision</code>, but since decimals are implemented with <code>i128</code>, a high
precision can cause multiplication and division to raise errors due to
overflow.</p>
<p>Importing the decimal module overloads and adds support for decimal
types to the following builtin functions:</p>
<ul>
<li>Arithemic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></li>
<li>Comparison operators: <code>=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
<li>Type conversions: <code>string</code>, <code>float</code>, <code>integer</code></li>
<li>Display: <code>repr</code>, <code>display</code></li>
</ul>
<p>Note that division is defined as floor division when the divisor is an
integer:</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (import-from &quot;stl/decimal&quot; decimal)
&gt;&gt;&gt; (/ (decimal 5) (decimal 2))
2.5
&gt;&gt;&gt; (/ (decimal 5) 2)
2.
</code></pre>
<p>Procedures defined in terms of basic numerical procedures will work with
decimal values once <code>stl/decimal</code> is imported - such as <code>range</code>, and all
functions from <code>stl/math</code> - with the caveat that some math functions may
truncate or apply floor divisions to their arguments:</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (import-from &quot;stl/decimal&quot; decimal)
&gt;&gt;&gt; (import-from &quot;stl/math&quot; remainder pow even?)

&gt;&gt;&gt; ; pow truncates the exponent (but not the base)
&gt;&gt;&gt; (pow (decimal &quot;2.5&quot;) 3)
15.625
&gt;&gt;&gt; (pow (decimal &quot;2.5&quot;) (decimal &quot;3.5&quot;))
15.625

&gt;&gt;&gt; ; even? and odd? only check the integer part of non-whole numbers
&gt;&gt;&gt; (even? (decimal &quot;2.5&quot;))
true

&gt;&gt;&gt; ; floor division, and remainder
&gt;&gt;&gt; (/ (decimal &quot;4.5&quot;) 2)
2
&gt;&gt;&gt; (remainder (decimal &quot;4.5&quot;) 2)
.5

&gt;&gt;&gt; ; true division and remainder
&gt;&gt;&gt; (/ (decimal &quot;4.5&quot;) (decimal 2))
2.25
&gt;&gt;&gt; ; it's technically correct that the remainder of true division is always zero,
&gt;&gt;&gt; ; but not very useful (may return not exactly zero due to rounding errors)
&gt;&gt;&gt; (remainder (decimal &quot;4.5&quot;) (decimal 2))
.000
</code></pre>
<p>Decimal numbers are represented as a an integer coefficient and an
(implicitly negative) integer exponent, with base 10. The exponent
encodes the number of significant digits, such that 2.5 is represented
as <code>(25 . 1)</code>, meaning 25x10<sup>-1</sup>, while 2.50 is represented as
<code>(250 . 2)</code>, meaning 250x10<sup>-2</sup>.</p>
<h4 id="decimal">decimal</h4>
<pre><code class="language-nohighlight">(decimal :integer|:float|:string|:decimal)
</code></pre>
<p>Convert value to a decimal. Raises an error if an unsupported type is
given.</p>
<pre><code class="language-nohighlight">&gt;&gt;&gt; ; Example
&gt;&gt;&gt; (import-from &quot;stl/decimal&quot; decimal)
&gt;&gt;&gt; (+ 1 2 3)
6
&gt;&gt;&gt; (+ (decimal &quot;12.5&quot;) (decimal &quot;0.25&quot;) 1)
13.75
</code></pre>
<hr />
<h4 id="round">round</h4>
<pre><code class="language-nohighlight">(round :decimal n:integer)
</code></pre>
<p>Round to n decimal places. Rounds up if the next digit is >= 5.</p>
<hr />
<h4 id="set-precision">set-precision</h4>
<pre><code class="language-nohighlight">(set-precision :integer)
</code></pre>
<p>Change maximum precision of decimals returned by multiplication and
division.</p>
<hr />
<h4 id="coef">coef</h4>
<pre><code class="language-nohighlight">(coef :decimal)
</code></pre>
<p>Get the coefficient of a decimal value.</p>
<hr />
<h4 id="expn">expn</h4>
<pre><code class="language-nohighlight">(expn :decimal)
</code></pre>
<p>Get the exponent of a decimal value. The exponent is implicitly negated,
i.e. a return value of 3 means 10<sup>-3</sup>.</p>
<hr />
<h3 id="stlunittest">stl/unittest</h3>
<p>Write and run unit tests with assertions.</p>
<h4 id="test">test</h4>
<pre><code class="language-nohighlight">(test name:string :expr ...)
</code></pre>
<p>A test is simply one or more expressions. It is considered a success if
no exceptions are raised when the body of the test is evaluated.</p>
<h4 id="test-suite">test-suite</h4>
<pre><code class="language-nohighlight">(test-suite name:string (test ...) ...)
</code></pre>
<p>Execute a series of tests, print a summary of the results, and raise an
error if any of the tests failed.</p>
<p>Set the environment variable <code>TEST_VERBOSE</code> to 1 to print more details.</p>
<pre><code class="language-nohighlight">; sometests.jibi
(import-from &quot;stl/unittest&quot; test test-suite assert-equal)
(test-suite &quot;very useful tests&quot;
    (test &quot;correct&quot; (assert-equal true true))
    (test &quot;suspicious&quot; (assert-equal true false)))
</code></pre>
<pre><code class="language-nohighlight">$ jibi sometests.jibi
Testing very useful tests...
Test suspicious: failed (#[error Exception: true is not equal to false])
Test results: 1 ok, 1 failed
Traceback:
  ...
Exception: Some tests failed.
</code></pre>
<h4 id="assert-not">assert-not</h4>
<pre><code class="language-nohighlight">(assert-not :bool)
</code></pre>
<p>Check if false.</p>
<h4 id="assert-eq">assert-eq</h4>
<pre><code class="language-nohighlight">(assert-eq :expr :expr)
</code></pre>
<p>Check (identity) equality.</p>
<h4 id="assert-equal">assert-equal</h4>
<pre><code class="language-nohighlight">(assert-equal :expr :expr)
</code></pre>
<p>Check (value) equality.</p>
<h4 id="assert-type">assert-type</h4>
<pre><code class="language-nohighlight">(assert-type :expr type)
</code></pre>
<p>Check type of expression.</p>
<h4 id="assert-raise">assert-raise</h4>
<pre><code class="language-nohighlight">(assert-raise :expr)
</code></pre>
<p>Check that the given expression raises an error when evaluated.</p>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '.';</script>
    <script src="js/theme_extra.js" defer></script>
    <script src="js/theme.js" defer></script>
      <script src="search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>

<!--
MkDocs version : 1.2.2
Build Date UTC : 2021-08-13 22:54:24.632534+00:00
-->
