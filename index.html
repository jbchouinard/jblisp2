<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="None">
  
  <link rel="canonical" href="https://jbchouinard.github.io/jbscheme/">
  <link rel="shortcut icon" href="img/favicon.ico">
  <title>JB Scheme</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Lanuage Reference";
    var mkdocs_page_input_path = "index.md";
    var mkdocs_page_url = "/jbscheme/";
  </script>
  
  <script src="js/jquery-2.1.1.min.js" defer></script>
  <script src="js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="." class="icon icon-home"> JB Scheme</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="./search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href=".">Lanuage Reference</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#types">Types</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#primitive-types">Primitive Types</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#string">string</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#symbol">symbol</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#integer">integer</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#bool">bool</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#nil">nil</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#composite-types">Composite Types</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#pair">pair</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#list">list</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#special-types">Special Types</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#quote">quote</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#error">error</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#callable-types">Callable Types</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#lambda">lambda</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#macro">macro</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#builtin-callable-types">Builtin Callable Types</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#function">function</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#specialform">specialform</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#forms">Forms</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#binding-and-assignment">Binding and Assignment</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#def">def</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#set">set!</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#let">let</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#lets">lets</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#function-definition">Function Definition</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#defn">defn</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#fn">fn</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#control-flow">Control Flow</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#if">if</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#begin">begin</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#comparison">Comparison</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#eq">eq?</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#equal">equal?</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#logical-operators">Logical Operators</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#not">not</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#pair-and-list-operations">Pair and List Operations</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#cons">cons</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#car">car</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#cdr">cdr</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#list_1">list</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#nil_1">nil?</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#list_2">list?</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#map">map</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#fold">fold</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#string-operations">String Operations</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#concat">concat</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#integer-operations">Integer Operations</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#add">add (+)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#mul">mul (*)</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#printing">Printing</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#print">print</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#repr">repr</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#display">display</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#type-inspection">Type Inspection</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#type">type</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#type_1">type?</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#quoting-and-evaluation">Quoting and Evaluation</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#quote_1">quote</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#eval">eval</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#apply">apply</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#evalfile">evalfile</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#macro-definition">Macro Definition</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#defmacro">defmacro</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#macro_1">macro</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exceptions">Exceptions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#error_1">error</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#raise">raise</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#try">try</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#assert">assert</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#system-procedures">System Procedures</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#getenv">getenv</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#exit">exit</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#debugging">Debugging</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#dd">dd</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ddp">ddp</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#dda">dda</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ddc">ddc</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#standard-libraries">Standard Libraries</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#math">math</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#unittest">unittest</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="" href="/jbscheme/JB Scheme Manual.pdf">PDF Manual</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="" href="/jbscheme/crate/jbscheme/index.html">Crate Documentation</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href=".">JB Scheme</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".">Docs</a> &raquo;</li>
    
      
    
    <li>Lanuage Reference</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h1 id="jb-scheme">JB Scheme</h1>
<p><strong>version 0.0.7</strong></p>
<p>A homebrew interpreted, non-RnRS compliant dialect of Scheme.</p>
<h2 id="types">Types</h2>
<h3 id="primitive-types">Primitive Types</h3>
<h4 id="string">string</h4>
<pre><code>"some-string"
</code></pre>
<p>String are immutable.</p>
<p><em>Evaluation Rule:</em> A <code>string</code> value evaluates to itself.</p>
<hr />
<h4 id="symbol">symbol</h4>
<pre><code>some-symbol
</code></pre>
<p>All <code>symbol</code> values are interned, therefore
<code>(eq? 'some-symbol 'some-symbol)</code> is true.</p>
<p><em>Evaluation Rule:</em> <code>symbol</code> values are variable names. When evaluated, a
<code>symbol</code> is replaced by the value of its binding in the nearest
enclosing scope where it is defined. An error is raised if <code>symbol</code> is
not bound in any enclosing scope.</p>
<hr />
<h4 id="integer">integer</h4>
<pre><code>100
</code></pre>
<p>The underlying type for <code>integer</code> is <code>i128</code>. Integer overflow terminates
the program.</p>
<p><em>Evaluation Rule:</em> An <code>integer</code> value evaluates to itself.</p>
<hr />
<h4 id="bool">bool</h4>
<pre><code>true
false
</code></pre>
<p>Only <code>bool</code> have truth values, therefore they are the only type that can
be used as predicates, e.g. for <code>if</code>.</p>
<p><em>Evaluation Rule:</em> A <code>bool</code> value evaluates to itself.</p>
<hr />
<h4 id="nil">nil</h4>
<pre><code>nil
</code></pre>
<p>In JB Scheme, <code>nil</code> and all empty lists <code>()</code> are the same object,
therefore <code>(eq? () ())</code> is true.</p>
<p><em>Evaluation Rule:</em> <code>nil</code> evaluates to itself.</p>
<hr />
<h3 id="composite-types">Composite Types</h3>
<h4 id="pair">pair</h4>
<pre><code>(cons :expr :expr)
</code></pre>
<p>The <code>pair</code>, also known as cons cell, is the basic Scheme compound data
type. It is simply a grouping of two values of any types (2-tuple); the
first and second values are sometimes referred to respectively as the
<code>car</code> and <code>cdr</code>.</p>
<p><em>Evaluation Rule:</em> <code>pair</code> values are evaluated by procedure application,
however, only <code>pair</code> values which are <code>lists</code>’s can be properly applied;
evaluating a non-list <code>pair</code> raises an error.</p>
<hr />
<h4 id="list">list</h4>
<pre><code>; code
(:callable :expr ...)
; data
()
(cons :expr (cons ()))
(list :expr ...)
</code></pre>
<p>A <code>list</code> value is either the empty list <code>()</code>, or ordered <code>pair</code>’s
terminated by <code>()</code>, where the <code>car</code> of the <code>pair</code> is an element of the
list, and the <code>cdr</code> is the rest of the list.</p>
<p>Scheme data and code are both represented as lists, which makes
meta-programming easy and fun. See <a href="#quoting-and-evaluation">Quoting and
Evaluation</a> and <a href="#macro-definition">Macro
Definition</a>.</p>
<p><em>Evaluation Rule:</em> The first value of the list is applied (called) with
the rest of the list as arguments. If the first value of the list is not
<a href="#callable-types"><code>callable</code></a>, an error is raised. Exception: the empty
list <code>()</code> is not applied, it evaluates to itself. See <a href="#function-definition">Function
Definition</a>.</p>
<hr />
<h3 id="special-types">Special Types</h3>
<h4 id="quote">quote</h4>
<pre><code>(quote :expr)
'expr
</code></pre>
<p>Any expression can be quoted, using either the <code>quote</code> form or a
starting apostrophe <code>'</code>.</p>
<p><em>Evaluation Rule:</em> A quoted expression evaluates to the expression. This
is useful to prevent <code>symbol</code> binding and procedure application. See
<a href="#quoting-and-evaluation">Quoting and Evaluation</a>.</p>
<hr />
<h4 id="error">error</h4>
<pre><code>(error "some-message")
</code></pre>
<p>Error values do no inherently do anything, until they are
<a href="#raise"><code>raise</code></a>’d as exceptions. See <a href="#exceptions">Exceptions</a>.</p>
<p><em>Evaluation Rule:</em> An <code>error</code> value evaluates to itself.</p>
<hr />
<h3 id="callable-types">Callable Types</h3>
<h4 id="lambda">lambda</h4>
<pre><code>(fn params :expr ...)
</code></pre>
<p>See <a href="#function-definition">Function Definition</a>.</p>
<p><em>Evaluation Rule:</em> A <code>lambda</code> value evaluates to itself. It is applied
when it is the first element of a <code>list</code>.</p>
<hr />
<h4 id="macro">macro</h4>
<pre><code>(macro params :expr ...)
</code></pre>
<p>See <a href="#macro-definition">Macro Definition</a>.</p>
<p><em>Evaluation Rule:</em> A <code>macro</code> value evaluates to itself. It is applied
when it is the first element of a <code>list</code>.</p>
<hr />
<h3 id="builtin-callable-types">Builtin Callable Types</h3>
<h4 id="function">function</h4>
<pre><code>; not constructable
</code></pre>
<p>Opaque type containing a builtin function.</p>
<p><em>Evaluation Rule:</em> A <code>function</code> value evaluates to itself. It is applied
when it is the first element of a <code>list</code>.</p>
<hr />
<h4 id="specialform">specialform</h4>
<pre><code>; not constructable
</code></pre>
<p>Opaque type containing a builtin macro.</p>
<p><em>Evaluation Rule:</em> A <code>specialform</code> value evaluates to itself. It is
applied when it is the first element of a <code>list</code>.</p>
<hr />
<h2 id="forms">Forms</h2>
<h3 id="binding-and-assignment">Binding and Assignment</h3>
<h4 id="def">def</h4>
<pre><code>(def name :expr)
</code></pre>
<p>Create and assign binding in local scope.</p>
<hr />
<h4 id="set">set!</h4>
<pre><code>(set! name :expr)
</code></pre>
<p>Change existing binding. Raises error if a binding does not already
exists.</p>
<hr />
<h4 id="let">let</h4>
<pre><code>(let name value:expr :expr ...)
</code></pre>
<p>Create a binding in a new local scope.</p>
<pre><code class="language-scheme">; Example
&gt;&gt;&gt; (let x 12 (display x))
12
</code></pre>
<hr />
<h4 id="lets">lets</h4>
<pre><code>(lets ((name value:expr) ...) :expr ...)
</code></pre>
<p>Create multiple bindings in a new local scope.</p>
<pre><code class="language-scheme">; Example
&gt;&gt;&gt; (lets ((x 5) (y 7))
...    (display x)
...    (display y))
5
7
</code></pre>
<hr />
<h3 id="function-definition">Function Definition</h3>
<h4 id="defn">defn</h4>
<pre><code>(defn name parameters :expr ...)
</code></pre>
<p>Create lambda function and bind it to <code>name</code>.</p>
<p>Variadic lambdas can be defined with formal parameters like <code>(x . xs)</code> -
there must be a single parameter after <code>.</code>, which will be a list
containing zero or more arguments depending on the number of arguments
passed.</p>
<pre><code class="language-scheme">; Example
&gt;&gt;&gt; (defn increment (x) (+ x 1))
&gt;&gt;&gt; (increment 1)
2
&gt;&gt;&gt; (defn variadic (x y . rest) rest)
&gt;&gt;&gt; (variadic 1)
Unhandled ApplyError &quot;expected at least 2 argument(s)&quot;
&gt;&gt;&gt; (variadic 1 2)
()
&gt;&gt;&gt; (variadic 1 2 3 4)
(3 4)
</code></pre>
<hr />
<h4 id="fn">fn</h4>
<pre><code>(fn parameters :expr ...)
</code></pre>
<p>Create a lambda (function). See <a href="#defn"><code>defn</code></a>.</p>
<hr />
<h3 id="control-flow">Control Flow</h3>
<h4 id="if">if</h4>
<pre><code>(if predicate:bool then:expr else:expr)
</code></pre>
<p>Evaluates only <code>then</code> or <code>else</code> conditonally on the value of
<code>predicate</code>.</p>
<hr />
<h4 id="begin">begin</h4>
<pre><code>(begin :expr ...)
</code></pre>
<p>Evaluate expressions sequentially and return value of last expression.</p>
<hr />
<h3 id="comparison">Comparison</h3>
<h4 id="eq">eq?</h4>
<pre><code>(eq? :expr :expr)
</code></pre>
<p>Identity comparison. Check if two values are the same object.</p>
<hr />
<h4 id="equal">equal?</h4>
<pre><code>(equal? :expr :expr)
</code></pre>
<p>Value comparison. Check if two values are equal.</p>
<hr />
<h3 id="logical-operators">Logical Operators</h3>
<h4 id="not">not</h4>
<pre><code>(not :bool)
</code></pre>
<hr />
<h3 id="pair-and-list-operations">Pair and List Operations</h3>
<h4 id="cons">cons</h4>
<pre><code>(cons left:expr right:expr)
</code></pre>
<p>Construct a pair.</p>
<hr />
<h4 id="car">car</h4>
<pre><code>(car :pair)
</code></pre>
<p>Get first item of a pair (head of list).</p>
<hr />
<h4 id="cdr">cdr</h4>
<pre><code>(cdr :pair)
</code></pre>
<p>Get second item of a pair (rest of list).</p>
<hr />
<h4 id="list_1">list</h4>
<pre><code>(list :expr ...)
</code></pre>
<p>Construct a list, which is a linked list made from pairs and termninated
by <code>nil</code>.</p>
<pre><code class="language-scheme">; Example
&gt;&gt;&gt; (equal? (list 1 2 3) (cons 1 (cons 2 (cons 3 nil))))
true
&gt;&gt;&gt; (equal? (list 1 2 3) (cons 1 (list 2 3)))
</code></pre>
<hr />
<h4 id="nil_1">nil?</h4>
<pre><code>(nil? :expr)
</code></pre>
<p>Check if value is the empty list (nil).</p>
<hr />
<h4 id="list_2">list?</h4>
<pre><code>(list? :expr)
</code></pre>
<p>Check if value is a nil-terminated list of ordered pairs.</p>
<hr />
<h4 id="map">map</h4>
<pre><code>(map f:procedure vals:list)
</code></pre>
<p>Applies <code>f</code> to each value in a list and return results in list.</p>
<pre><code class="language-scheme">; Example
&gt;&gt;&gt; (map (fn (x) (* 2 x)) (list 1 2 3))
(2 4 6)
</code></pre>
<hr />
<h4 id="fold">fold</h4>
<pre><code>(fold f:procedure init:expr vals:list)
</code></pre>
<p>Applies <code>f</code> to each value in a list and accumulate results in <code>init</code>.</p>
<pre><code class="language-scheme">; Example
&gt;&gt;&gt; (fold + 0 (list 1 2 3))
6
&gt;&gt;&gt; (fold cons () (list 1 2 3))
(3 2 1)
</code></pre>
<hr />
<h3 id="string-operations">String Operations</h3>
<h4 id="concat">concat</h4>
<pre><code>(concat :string ...)
</code></pre>
<p>Concatenate multiple strings.</p>
<pre><code class="language-scheme">; Example
&gt;&gt;&gt; (concat &quot;foo&quot; &quot;bar&quot; &quot;baz&quot;)
&quot;foobarbaz&quot;
</code></pre>
<hr />
<h3 id="integer-operations">Integer Operations</h3>
<h4 id="add">add (+)</h4>
<pre><code>(+ :integer ...)
</code></pre>
<h4 id="mul">mul (*)</h4>
<pre><code>(* :integer ...)
</code></pre>
<hr />
<h3 id="printing">Printing</h3>
<h4 id="print">print</h4>
<pre><code>(print :string)
</code></pre>
<hr />
<h4 id="repr">repr</h4>
<pre><code>(repr :expr)
</code></pre>
<p>Get string representation of a value.</p>
<hr />
<h4 id="display">display</h4>
<pre><code>(display :expr)
</code></pre>
<p>Print string representation of a value.</p>
<hr />
<h3 id="type-inspection">Type Inspection</h3>
<h4 id="type">type</h4>
<pre><code>(type :expr)
</code></pre>
<p>Inspect type of a value.</p>
<pre><code class="language-scheme">; Example
&gt;&gt;&gt; (type &quot;foo&quot;)
string
</code></pre>
<hr />
<h4 id="type_1">type?</h4>
<pre><code>(type? :expr type)
(string? :expr)
(symbol? :expr)
...
</code></pre>
<p>Test type of a value. There are also convenience functions for every
type.</p>
<pre><code class="language-scheme">; Example
&gt;&gt;&gt; (type? &quot;foo&quot; string)
true
&gt;&gt;&gt; (integer? &quot;foo&quot;)
false
</code></pre>
<hr />
<h3 id="quoting-and-evaluation">Quoting and Evaluation</h3>
<h4 id="quote_1">quote</h4>
<pre><code>(quote :expr)
</code></pre>
<p>A quoted expression evaluates to the expression.</p>
<pre><code class="language-scheme">; Example
&gt;&gt;&gt; (def a 100)
&gt;&gt;&gt; a
100
&gt;&gt;&gt; (quote a)
a
&gt;&gt;&gt; (+ 5 5)
10
&gt;&gt;&gt; (quote (+ 5 5))
(+ 5 5)
</code></pre>
<hr />
<h4 id="eval">eval</h4>
<pre><code>(eval :expr)
</code></pre>
<p>Evaluate an expression.</p>
<pre><code class="language-scheme">; Example
&gt;&gt;&gt; (def expr (quote (+ 5 5)))
&gt;&gt;&gt; expr
(+ 5 5)
&gt;&gt;&gt; (eval expr)
10
</code></pre>
<hr />
<h4 id="apply">apply</h4>
<pre><code>(apply :procedure :list)
</code></pre>
<p>Apply a procedure to a list of arguments.</p>
<pre><code class="language-scheme">; Example
&gt;&gt;&gt; (apply + (list 1 2 3))
6
</code></pre>
<hr />
<h4 id="evalfile">evalfile</h4>
<pre><code>(evalfile filename:string)
</code></pre>
<p>Evaluate file in the global environment.</p>
<hr />
<h3 id="macro-definition">Macro Definition</h3>
<h4 id="defmacro">defmacro</h4>
<pre><code>(defmacro name formals :expr ...)
</code></pre>
<p>jbscheme macros are “procedural”; they are simply lambdas which return
code.</p>
<p>The body of the macro is first evaluated in the macro’s lexical
environment. Then the resulting expression is evaluated in the caller’s
environment.</p>
<p>Beware of capturing variables from the macro’s environment; if you want
to refer to variables in the invocation environment, use quotation.</p>
<p>This <code>add-x</code> macro captures the global binding for <code>x</code>:</p>
<pre><code>&gt;&gt;&gt; (defmacro add-x (y) (list + x y))
&gt;&gt;&gt; (def x 100)
&gt;&gt;&gt; (add-x 5)
105
&gt;&gt;&gt; (set! x 200)
&gt;&gt;&gt; (add-x 5)
205
&gt;&gt;&gt; ((fn (x) (add-x 5)) 1000)
205
</code></pre>
<p>In this version, <code>x</code> is not captured; the value of <code>x</code> is taken from the
local scope where the macro is called:</p>
<pre><code>&gt;&gt;&gt; (def x 100)
&gt;&gt;&gt; (defmacro add-x (y) (list + 'x y))
&gt;&gt;&gt; ((fn (x) (add-x 5)) 1000)
1005
</code></pre>
<hr />
<h4 id="macro_1">macro</h4>
<pre><code>(macro formals :expr ...)
</code></pre>
<p>Create macro. See <a href="#defmacro">‘defmacro’</a>.</p>
<hr />
<h3 id="exceptions">Exceptions</h3>
<p>Errors can be raised to interrupt program flow, and can be caught with
the <code>try</code> form.</p>
<h4 id="error_1">error</h4>
<pre><code>(error :string)
</code></pre>
<h4 id="raise">raise</h4>
<pre><code>(raise :error)
</code></pre>
<h4 id="try">try</h4>
<pre><code>(try body:expr catch:expr)
</code></pre>
<p>Try evaluating <code>body</code>. If an error is raised, evaluate <code>catch</code>; the
raised error value is bound to <code>err</code> when <code>catch</code> is evaluated.</p>
<pre><code class="language-scheme">; Example
&gt;&gt;&gt; (defn errored ()
...     (raise (error &quot;oh no!&quot;))
...     (print &quot;never evaluated&quot;))
&gt;&gt;&gt; (errored)
Unhandled Error: oh no!
&gt;&gt;&gt; (try (print &quot;no error&quot;) (print (concat &quot;handled &quot; (repr err))))
no error
&gt;&gt;&gt; (try (errored) (print (concat &quot;handled &quot; (repr err))))
handled #[error Exception &quot;oh no!&quot;]
</code></pre>
<hr />
<h4 id="assert">assert</h4>
<pre><code>(assert predicate:bool)
</code></pre>
<p>Raises an exception if <code>predicate</code> is false.</p>
<hr />
<h3 id="system-procedures">System Procedures</h3>
<h4 id="getenv">getenv</h4>
<pre><code>(getenv var:string)
</code></pre>
<p>Get value of environment variable. Raises exception if the variable is
not set or contains non-UTF8 characters.</p>
<hr />
<h4 id="exit">exit</h4>
<pre><code>(exit :integer)
</code></pre>
<p>Exit program with a status code.</p>
<hr />
<h3 id="debugging">Debugging</h3>
<h4 id="dd">dd</h4>
<pre><code>(dd :expr)
</code></pre>
<p>Print Rust struct debug.</p>
<hr />
<h4 id="ddp">ddp</h4>
<pre><code>(ddp :expr)
</code></pre>
<p>Pretty print Rust struct debug.</p>
<hr />
<h4 id="dda">dda</h4>
<pre><code>(dda :expr)
</code></pre>
<p>Print pointer address.</p>
<hr />
<h4 id="ddc">ddc</h4>
<pre><code>(ddc :lambda|:macro)
</code></pre>
<p>Print code of (non-builtin) lambda or macro.</p>
<hr />
<h2 id="standard-libraries">Standard Libraries</h2>
<h3 id="math">math</h3>
<h3 id="unittest">unittest</h3>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '.';</script>
    <script src="js/theme_extra.js" defer></script>
    <script src="js/theme.js" defer></script>
      <script src="search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>

<!--
MkDocs version : 1.2.2
Build Date UTC : 2021-08-07 21:02:42.182023+00:00
-->
