(def nil ())
(def true (eq? nil nil))
(def false (not true))
(def else true)

(def inf (/ 0.0))
(def -inf (/ -0.0))
(def nan (/ 0.0 0.0))

(def defmacro
    (macro (name params . exprs)
        (list def name (cons nmacro (cons (repr name) (cons params exprs))))))

(defmacro defn (name params . exprs)
    (list def name (cons nfn (cons (repr name) (cons params exprs)))))

(defmacro setglobal! (name expr)
    (list env-set! (list env-globals) (list quote name) expr))

(defmacro defglobal (name expr)
    (list env-def (list env-globals) (list quote name) expr))

(defmacro defnglobal (name params . exprs)
    (list defglobal name (cons nfn (cons (repr name) (cons params exprs)))))

(defmacro type? (val t) (list eq? (list type val) (list quote t)))

(defn nil? (x) (equal? x nil))
(defn string? (val) (type? val string))
(defn symbol? (val) (type? val symbol))
(defn integer? (val) (type? val integer))
(defn float? (val) (type? val float))
(defn pair? (val) (type? val pair))
(defn error? (val) (type? val error))
(defn bool? (val) (type? val bool))
(defn lambda? (val) (type? val lambda))
(defn procmacro? (val) (type? val procmacro))
(defn builtin? (val) (type? val builtin))
(defn specialform? (val) (type? val specialform))
(defn quote? (val) (type? val quote))
(defn env? (val) (type? val env))

(def empty? nil?)

(defn string (v) (repr v))

(defn integer (v) (cond
    ((string? v) (parse-integer v))
    (else (as-integer v))))

(defn float (v) (cond
    ((string? v) (parse-float v))
    (else (as-float v))))

(defn nth (idx lst)
    (if (<= idx 0)
        (car lst)
        (nth (- idx 1) (cdr lst))))

(defn lcons (. items)
    (if (nil? (cdr items))
        (car items)
        (cons (car items) (apply lcons (cdr items)))))

(defn display (x)
    (print (repr x)))

(defn assert-msg (pred reason)
    (if pred () (raise (exception reason))))

(defn assert (pred)
    (assert-msg pred "assertion failed"))

(defmacro deferror (name)
    (list defn name (list 'reason) (list error (list quote name) 'reason)))

(defn apply (op args)
    ((macro ()
        (cons op (map (fn (arg) (list quote arg)) args)))))

(defmacro let (bindings . exprs)
    (if (empty? bindings)
        (list (lcons fn () exprs))
        (list
            (list fn
                (list (nth 0 (car bindings)))
                (lcons let (cdr bindings) exprs))
            (nth 1 (car bindings)))))

(defmacro if (pred then-clause else-clause) ()
    (list cond (list pred then-clause) (list else else-clause)))

(defn map (f lst)
    (if (nil? lst)
        ()
        (cons
            (f (car lst))
            (map f (cdr lst)))))

(defn fold (f init lst)
    (if (nil? lst)
        init
        (fold f (f (car lst) init) (cdr lst))))

(defn in-bounds? (x a b)
    (let ((min (if (< a b) a b))
          (max (if (> a b) a b)))
        (and (<= x max) (>= x min))))

(defn range (start end . step)
    (let ((step (if (empty? step) 1 (car step))))
        (defn range-rec (n)
            (if (in-bounds? n start end)
                (cons n (range-rec (+ n step)))
                ()))
        (range-rec start)))

(defn env-globals ()
    (defn globals-rec (e)
        (let ((pe (env-parent e)))
            (if (nil? pe) e (globals-rec pe))))
    (globals-rec (env)))

(defmacro env-lookup-rec (x . syms)
    (if (empty? syms)
        x
        (cons env-lookup-rec (cons (list env-lookup x (list quote (car syms))) (cdr syms)))))

; TODO
(def vector list)

(defmacro use (mod . names)
    (cons begin (map (fn (name)
        (list defglobal name (list env-lookup mod (list quote name))))
        names)))

(defmacro import-from (mod . names)
    (import mod as some-module)
    (list let (list (list 'some-module some-module))
        (cons use (cons 'some-module names))))

(defn left-pad (s char n)
    (assert (equal? 1 (len char)))
    (if (< (len s) n)
        (concat
            (apply concat (map
                (fn (_) char)
                (range 0 (- n (len s)))))
            s)
        s))

(defn any (. xs) (fold or false xs))

(defn all (. xs) (fold and true xs))
