(def nil ())
(def true (eq? nil nil))
(def false (not true))
(def else true)

(def defmacro
    (macro (name params . exprs)
        (list def name (cons nmacro (cons (repr name) (cons params exprs))))))

(defmacro defn (name params . exprs)
    (list def name (cons nfn (cons (repr name) (cons params exprs)))))

(defmacro type? (val t) (list equal? (list type val) (list quote t)))

(defn nil? (x) (equal? x nil))
(defn string? (val) (type? val string))
(defn symbol? (val) (type? val symbol))
(defn integer? (val) (type? val integer))
(defn pair? (val) (type? val pair))
(defn error? (val) (type? val error))
(defn bool? (val) (type? val bool))
(defn lambda? (val) (type? val lambda))
(defn procmacro? (val) (type? val procmacro))
(defn builtin? (val) (type? val builtin))
(defn specialform? (val) (type? val specialform))
(defn quote? (val) (type? val quote))
(defn env? (val) (type? val env))

(def empty? nil?)

(defn nth (idx lst)
    (if (<= idx 0)
        (car lst)
        (nth (- idx 1) (cdr lst))))

(defn lcons (. items)
    (if (nil? (cdr items))
        (car items)
        (cons (car items) (apply lcons (cdr items)))))

(defn display (x)
    (print (repr x)))

(defn assert-msg (pred reason)
    (if pred () (raise (exception reason))))

(defn assert (pred)
    (assert-msg pred "assertion failed"))

(defmacro deferror (name)
    (list defn name (list 'reason) (list error (list quote name) 'reason)))

(defn apply (op args)
    ((macro ()
        (cons op (map (fn (arg) (list quote arg)) args)))))

(defmacro let (bindings . exprs)
    (if (empty? bindings)
        (list (lcons fn () exprs))
        (list
            (list fn
                (list (nth 0 (car bindings)))
                (lcons let (cdr bindings) exprs))
            (nth 1 (car bindings)))))

(defmacro if (pred then-clause else-clause) ()
    (list cond (list pred then-clause) (list else else-clause)))

(defn map (f lst)
    (if (nil? lst)
        ()
        (cons
            (f (car lst))
            (map f (cdr lst)))))

(defn fold (f init lst)
    (if (nil? lst)
        init
        (fold f (f (car lst) init) (cdr lst))))

(defn range (start end)
    (defn range-rec (n)
        (if (>= n end)
            nil
            (cons n (range-rec (+ n 1)))))
    (range-rec start))

(defn env-globals ()
    (defn globals-rec (e)
        (let ((pe (env-parent e)))
            (if (nil? pe) e (globals-rec pe))))
    (globals-rec (env)))

(defmacro env-lookup-rec (x . syms)
    (if (empty? syms)
        x
        (cons env-lookup-rec (cons (list env-lookup x (list quote (car syms))) (cdr syms)))))

(defmacro setglobal! (name expr)
    (list env-set! (list env-globals) (list quote name) expr))

(defmacro defglobal (name expr)
    (list env-def (list env-globals) (list quote name) expr))

; TODO
(def vector list)

(defmacro use (mod . names)
    (cons begin (map (fn (name)
        (list defglobal name (list env-lookup mod (list quote name))))
        names)))

(defmacro import-from (mod . names)
    (import mod as some-module)
    (list let (list (list 'some-module some-module))
        (cons use (cons 'some-module names))))
