(def nil ())
(def true (eq? nil nil))
(def false (not true))

(def defmacro
    (macro (name params . exprs)
        (list def name (cons macro (cons params exprs)))))

(defmacro defn (name params . exprs)
    (list def name (cons fn (cons params exprs))))

(defmacro type? (val t) (list equal? (list type val) (list quote t)))

(defn nil? (x) (equal? x nil))
(defn string? (val) (type? val string))
(defn symbol? (val) (type? val symbol))
(defn integer? (val) (type? val integer))
(defn pair? (val) (type? val pair))
(defn error? (val) (type? val error))
(defn bool? (val) (type? val bool))
(defn lambda? (val) (type? val lambda))
(defn procmacro? (val) (type? val procmacro))
(defn builtin? (val) (type? val builtin))
(defn specialform? (val) (type? val specialform))
(defn quote? (val) (type? val quote))
(defn env? (val) (type? val env))

(def empty? nil?)

(defn display (x)
    (print (repr x)))

(defn assert-msg (pred reason)
    (if pred () (raise (exception reason))))

(defn assert (pred)
    (assert-msg pred "assertion failed"))

(defmacro deferror (name)
    (list defn name (list 'reason) (list error (list quote name) 'reason)))

(defn apply (op args) (eval (cons op args)))

(defmacro let (sym val . exprs)
    (list (list fn (list sym) (cons begin exprs)) val))

(defn map (f lst)
    (if (nil? lst)
        ()
        (cons
            (f (car lst))
            (map f (cdr lst)))))

(defn fold (f init lst)
    (if (nil? lst)
        init
        (fold f (f (car lst) init) (cdr lst))))

(defn range (start end)
    (defn range-rec (n)
        (if (eq? 0 (- n end))
            nil
            (cons n (range-rec (+ n 1)))))
    (range-rec start))

(defn env-globals ()
    (defn globals-rec (e)
        (let pe (env-parent e)
            (if (nil? pe) e (globals-rec pe))))
    (globals-rec (env)))

(defmacro env-lookup-rec (x . syms)
    (if (empty? syms)
        x
        (cons env-lookup-rec (cons (list env-lookup x (list quote (car syms))) (cdr syms)))))

(defmacro setglobal! (name expr)
    (list env-set! (list env-globals) (list quote name) expr))

(defmacro defglobal (name expr)
    (list env-def (list env-globals) (list quote name) expr))

; TODO
(def vector list)

(defmacro use (mod . names)
    (cons begin (map (fn (name)
        (list defglobal name (list env-lookup mod (list quote name))))
        names)))

(defmacro import-from (mod . names)
    (import mod as some-module)
    (list let 'some-module some-module
        (cons use (cons 'some-module names))))
