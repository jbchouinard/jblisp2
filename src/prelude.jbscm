(def nil ())
(def true (eq? nil nil))
(def false (not true))

(def :nil (type ()))
(def :pair (type (cons nil nil)))
(def :lambda (type (fn () ())))
(def :macro (type (macro () ())))
(def :integer (type 1))
(def :bool (type true))
(def :string (type ""))
(def :symbol (type 'a))
(def :quoted (type ''a))
(def :error (type (error "")))
(def :builtin (type +))
(def :specialform (type if))

(def defmacro
    (macro (name params code)
        (list def name (list macro params code))))

(defmacro defn (name params code)
    (list def name (list fn params code)))

(defn type? (val t) (equal? (type val) t))

(defn string? (val) (type? val :string))
(defn symbol? (val) (type? val :symbol))
(defn integer? (val) (type? val :integer))
(defn pair? (val) (type? val :pair))
(defn error? (val) (type? val :error))
(defn bool? (val) (type? val :bool))
(defn lambda? (val) (type? val :lambda))
(defn macro? (val) (type? val :macro))
(defn builtin? (val) (type? val :builtin))
(defn specialform? (val) (type? val :specialform))
(defn quoted? (val) (type? val :quoted))

(defn nil? (x)
    (equal? x nil))

(defn display (x)
    (print (repr x)))

(defn assert (pred)
    (if pred () (raise (error "assertion"))))

(defn assert-msg (pred reason)
    (if pred () (raise (error reason))))

(defn apply (op args) (eval (cons op args)))

(defmacro let (sym val body)
    (list (list fn (list sym) body) val))

(defn map (f lst)
    (if (nil? lst)
        ()
        (cons
            (f (car lst))
            (map f (cdr lst)))))

(defn fold (f init lst)
    (if (nil? lst)
        init
        (fold f (f (car lst) init) (cdr lst))))

(defn range (start end) (begin
    (defn range-rec (n)
        (if (eq? 0 (- n end))
            nil
            (cons n (range-rec (+ n 1)))))
    (range-rec start)))

(defn neg (n) (* n -1))

(defn - (x y) (+ x (neg y)))
