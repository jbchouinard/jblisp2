(def nil ())
(def true (eq? nil nil))
(def false (not true))

(def defmacro
    (macro (name params . exprs)
        (list def name (cons macro (cons params exprs)))))

(defmacro defn (name params . exprs)
    (list def name (cons fn (cons params exprs))))

(defmacro type? (val t) (list equal? (list type val) (list quote t)))

(defn nil? (x) (equal? x nil))
(defn string? (val) (type? val string))
(defn symbol? (val) (type? val symbol))
(defn integer? (val) (type? val integer))
(defn pair? (val) (type? val pair))
(defn error? (val) (type? val error))
(defn bool? (val) (type? val bool))
(defn lambda? (val) (type? val lambda))
(defn macro? (val) (type? val macro))
(defn builtin? (val) (type? val builtin))
(defn specialform? (val) (type? val specialform))
(defn quote? (val) (type? val quote))

(defn display (x)
    (print (repr x)))

(defn assert-msg (pred reason)
    (if pred () (raise (error reason))))

(defn assert (pred)
    (assert-msg pred "assertion failed"))

(defn apply (op args) (eval (cons op args)))

(defmacro let (sym val . exprs)
    (list (list fn (list sym) (cons begin exprs)) val))

(defn map (f lst)
    (if (nil? lst)
        ()
        (cons
            (f (car lst))
            (map f (cdr lst)))))

(defn fold (f init lst)
    (if (nil? lst)
        init
        (fold f (f (car lst) init) (cdr lst))))

(defn range (start end)
    (defn range-rec (n)
        (if (eq? 0 (- n end))
            nil
            (cons n (range-rec (+ n 1)))))
    (range-rec start))

(defn - (x . xs)
    (if (nil? xs)
        (* -1 x)
        (apply + (cons x (map - xs)))))

; A hack until I make a real import system
(defmacro import (mod) (list evalfile (concat mod ".jbscm")))
