{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Jibi Scheme version 0.1.1 A homebrew interpreted, non-RnRS compliant dialect of Scheme. Types Primitive Types string \"some-string\" String are immutable. Evaluation Rule: A string value evaluates to itself. symbol some-symbol All symbol values are interned, therefore (eq? 'some-symbol 'some-symbol) is true. Evaluation Rule: symbol values are variable names. When evaluated, a symbol is replaced by the value of its binding in the nearest enclosing scope where it is defined. An error is raised if symbol is not bound in any enclosing scope. integer 100 The underlying type for integer is i128 . Integer overflow terminates the program. Evaluation Rule: An integer value evaluates to itself. bool true false Only bool have truth values, therefore they are the only type that can be used as predicates, e.g. for if . Evaluation Rule: A bool value evaluates to itself. nil nil In Jibi Scheme, nil and all empty lists () are the same object, therefore (eq? () ()) is true. Evaluation Rule: nil evaluates to itself. Composite Types pair (cons :expr :expr) The pair , also known as cons cell, is the basic Scheme compound data type. It is simply a grouping of two values of any types (2-tuple); the first and second values are sometimes referred to respectively as the car and cdr . Evaluation Rule: pair values are evaluated by procedure application, however, only pair values which are list \u2019s can be properly applied; evaluating a non-list pair raises an error. list ; code (:callable :expr ...) ; data () (cons :expr (cons ())) (list :expr ...) A list value is either the empty list () , or ordered pair \u2019s terminated by () , where the car of the pair is an element of the list, and the cdr is the rest of the list. Scheme data and code are both represented as lists, which makes meta-programming easy and fun. See Quoting and Evaluation and Macro Definition . Evaluation Rule: The first value of the list is applied (called) with the rest of the list as arguments. If the first value of the list is not callable , an error is raised. Exception: the empty list () is not applied, it evaluates to itself. See Function Definition . Special Types quote (quote :expr) 'expr Any expression can be quoted, using either the quote form or a starting apostrophe ' . Evaluation Rule: A quoted expression evaluates to the expression. This is useful to prevent symbol binding and procedure application. See Quoting and Evaluation . error (error type \"some-message\") Error values do no inherently do anything, until they are raise \u2019d as exceptions. See Exceptions . Evaluation Rule: An error value evaluates to itself. Callable Types lambda (fn params :expr ...) See Function Definition . Evaluation Rule: A lambda value evaluates to itself. It is applied when it is the first element of a list . procmacro (macro params :expr ...) Procedural macros. See Macro Definition . Evaluation Rule: A procmacro value evaluates to itself. It is applied when it is the first element of a list . Builtin Callable Types function ; not constructable Opaque type containing a builtin function. Evaluation Rule: A function value evaluates to itself. It is applied when it is the first element of a list . specialform ; not constructable Opaque type containing a builtin macro. Evaluation Rule: A specialform value evaluates to itself. It is applied when it is the first element of a list . Forms Binding and Assignment def (def name :expr) Create and assign binding in local scope. set! (set! name :expr) Change existing binding. Raises error if a binding does not already exists. let (let name value:expr :expr ...) Create a binding in a new local scope. ; Example >>> (let x 12 (display x)) 12 lets (lets ((name value:expr) ...) :expr ...) Create multiple bindings in a new local scope. ; Example >>> (lets ((x 5) (y 7)) ... (display x) ... (display y)) 5 7 defglobal (defglobal name :expr) Create and assign binding in global env. setglobal! (setglobal! name :expr) Change existing binding in global env. Raises error if a binding does not already exists. Function Definition defn (defn name parameters :expr ...) Create lambda function and bind it to name . Variadic lambdas can be defined with formal parameters like (x . xs) - there must be a single parameter after . , which will be a list containing zero or more arguments depending on the number of arguments passed. ; Example >>> (defn increment (x) (+ x 1)) >>> (increment 1) 2 >>> (defn variadic (x y . rest) rest) >>> (variadic 1) Unhandled ApplyError \"expected at least 2 argument(s)\" >>> (variadic 1 2) () >>> (variadic 1 2 3 4) (3 4) fn (fn parameters :expr ...) Create a lambda (function). See defn . Control Flow if (if predicate:bool then:expr else:expr) Evaluates only then or else conditonally on the value of predicate . begin (begin :expr ...) Evaluate expressions sequentially and return value of last expression. Comparison eq? (eq? :expr :expr) Identity comparison. Check if two values are the same object. equal? (equal? :expr :expr) Value comparison. Check if two values are equal. Logical Operators not (not :bool) Pair and List Operations cons (cons left:expr right:expr) Construct a pair. car (car :pair) Get first item of a pair (head of list). cdr (cdr :pair) Get second item of a pair (rest of list). list (list :expr ...) Construct a list, which is a linked list made from pairs and terminated by nil . ; Example >>> (equal? (list 1 2 3) (cons 1 (cons 2 (cons 3 nil)))) true >>> (equal? (list 1 2 3) (cons 1 (list 2 3))) empty? (empty? :expr) Check if value is the empty list (nil). list? (list? :expr) Check if value is a nil-terminated list of ordered pairs. map (map f:procedure vals:list) Applies f to each value in a list and return results in list. ; Example >>> (map (fn (x) (* 2 x)) (list 1 2 3)) (2 4 6) fold (fold f:procedure init:expr vals:list) Applies f to each value in a list and accumulate results in init . ; Example >>> (fold + 0 (list 1 2 3)) 6 >>> (fold cons () (list 1 2 3)) (3 2 1) range (range from:integer to:integer) Produce list of integers for range [ from , to ), where to >= from . String Operations concat (concat :string ...) Concatenate multiple strings. ; Example >>> (concat \"foo\" \"bar\" \"baz\") \"foobarbaz\" Integer Operations + (+ :integer ...) - (- :integer ...) * (* :integer ...) / (/ :integer ...) Printing print (print :string) repr (repr :expr) Get string representation of a value. display (display :expr) Print string representation of a value. Modules (Work in progress.) jibi has a basic namespaced module system. A module is simply a .jibi file. They provide no privacy, all variables defined in the module scope are accessible to importers. Module files are only evaluated once, re-importing gets a reference to the existing module. At the moment only the current working directory is searched to find modules, thus importing \u201cstl/unittest\u201d looks for the file ./stl/unittest.jibi'. import (import module:string as name) Import module and bind it to name . ; Example >>> (import \"stl/math\" as math) >>> (math::product (list 2 3 4)) 24 use (use module:symbol name ...) Bind a name from a module into the global scope. ; Example >>> (import \"stl/math\" as math) >>> (use math product sum) >>> (product (list 2 3 4)) 24 import-from (import-from module:string name ...) Import specific names from a module. ; Example >>> (import-from \"stl/math\" product sum) >>> (sum (list 2 3 4)) 9 >>> (product (list 2 3 4)) 24 Type Inspection type (type :expr) Inspect type of a value. ; Example >>> (type \"foo\") string type? (type? :expr type) (string? :expr) (symbol? :expr) ... Test type of a value. There are also convenience functions for every type. ; Example >>> (type? \"foo\" string) true >>> (integer? \"foo\") false Quoting and Evaluation quote (quote :expr) A quoted expression evaluates to the expression. ; Example >>> (def a 100) >>> a 100 >>> (quote a) a >>> (+ 5 5) 10 >>> (quote (+ 5 5)) (+ 5 5) eval (eval :expr) Evaluate an expression. ; Example >>> (def expr (quote (+ 5 5))) >>> expr (+ 5 5) >>> (eval expr) 10 evalfile (evalfile filename:string) Evaluate file in the global environment. apply (apply :procedure :list) Apply a procedure to a list of arguments. ; Example >>> (apply + (list 1 2 3)) 6 Macro Definition defmacro (defmacro name formals :expr ...) jibi macros are \u201cprocedural\u201d; they are simply lambdas which return code. The body of the macro is first evaluated in the macro\u2019s lexical environment. Then the resulting expression is evaluated in the caller\u2019s environment. Beware of capturing variables from the macro\u2019s environment; if you want to refer to variables in the invocation environment, use quotation. This add-x macro captures the global binding for x : >>> (defmacro add-x (y) (list + x y)) >>> (def x 100) >>> (add-x 5) 105 >>> (set! x 200) >>> (add-x 5) 205 >>> ((fn (x) (add-x 5)) 1000) 205 In this version, x is not captured; the value of x is taken from the local scope where the macro is called: >>> (def x 100) >>> (defmacro add-x (y) (list + 'x y)) >>> ((fn (x) (add-x 5)) 1000) 1005 macro (macro formals :expr ...) Create macro. See \u2018defmacro\u2019 . Exceptions Errors can be raised to interrupt program flow, and can be caught with the try form. error (error type:symbol reason:string) Create error with custom type. exception (exception reason:string) Create error of type Exception. raise (raise :error) Raise an error (can be any error type, not just Exception). try (try body:expr catch:expr) Try evaluating body . If an error is raised, evaluate catch ; the raised error value is bound to err when catch is evaluated. ; Example >>> (defn errored () ... (raise (exception \"oh no!\")) ... (print \"never evaluated\")) >>> (errored) Unhandled Error: oh no! >>> (try (print \"no error\") (print (concat \"handled \" (repr err)))) no error >>> (try (errored) (print (concat \"handled \" (repr err)))) handled #[error Exception \"oh no!\"] assert (assert predicate:bool) Raises an exception if predicate is false. Environment Procedures env (env) Get the nearest enclosing environment (most local scope). env-lookup (env-lookup :env :symbol) Look up symbol in the given environment. env-def (env-def :env :symbol :expr) Define symbol in the given environment. env-set (env-set! :env :symbol :expr) Set symbol in the given environment. env-parent (env-parent :env) Get parent env, or nil if there is no parent env. env-globals (env-globals) Get the global environment. System Procedures environment-variable (environment-variable var:string) Get value of environment variable. Raises exception if the variable is not set or contains non-UTF8 characters. exit (exit :integer) Exit program with a status code. Debugging dd (dd :expr) Print Rust struct debug. ddp (ddp :expr) Pretty print Rust struct debug. dda (dda :expr) Print pointer address. ddc (ddc :lambda|:procmacro) Print code of (non-builtin) lambda or macro. ddm (ddm :procmacro :expr ...) Print code generated by a procmacro for the given arguments. Standard Library (STL) I hope you were not expecting a real standard library. You can have some unit testing utilities for consolation. stl/unittest Write and run unit tests with assertions. test (test name:string :expr ...) A test is simply one or more expressions. It is considered a success if no exceptions are raised when the body of the test is evaluated. test-suite (test-suite name:string (test ...) ...) Execute a series of tests, print a summary of the results, and raise an error if any of the tests failed. Set the environment variable TEST_VERBOSE to 1 to print more details. ; sometests.jibi (import-from \"stl/unittest\" test test-suite assert-equal) (test-suite \"very useful tests\" (test \"correct\" (assert-equal true true)) (test \"suspicious\" (assert-equal true false))) $ jibi sometests.jibi Testing very useful tests... suspicious: failed (#[error Exception: true is not equal to false]) Test results: 1 ok, 1 failed Traceback: ... Exception: Some tests failed. assert-not (assert-not :bool) Check if false. assert-eq (assert-eq :expr :expr) Check (identity) equality. assert-equal (assert-equal :expr :expr) Check (value) equality. assert-type (assert-type :expr type) Check type of expression. assert-raise (assert-raise :expr) Check that the given expression raises an error when evaluated.","title":"Language Reference"},{"location":"#jibi-scheme","text":"version 0.1.1 A homebrew interpreted, non-RnRS compliant dialect of Scheme.","title":"Jibi Scheme"},{"location":"#types","text":"","title":"Types"},{"location":"#primitive-types","text":"","title":"Primitive Types"},{"location":"#string","text":"\"some-string\" String are immutable. Evaluation Rule: A string value evaluates to itself.","title":"string"},{"location":"#symbol","text":"some-symbol All symbol values are interned, therefore (eq? 'some-symbol 'some-symbol) is true. Evaluation Rule: symbol values are variable names. When evaluated, a symbol is replaced by the value of its binding in the nearest enclosing scope where it is defined. An error is raised if symbol is not bound in any enclosing scope.","title":"symbol"},{"location":"#integer","text":"100 The underlying type for integer is i128 . Integer overflow terminates the program. Evaluation Rule: An integer value evaluates to itself.","title":"integer"},{"location":"#bool","text":"true false Only bool have truth values, therefore they are the only type that can be used as predicates, e.g. for if . Evaluation Rule: A bool value evaluates to itself.","title":"bool"},{"location":"#nil","text":"nil In Jibi Scheme, nil and all empty lists () are the same object, therefore (eq? () ()) is true. Evaluation Rule: nil evaluates to itself.","title":"nil"},{"location":"#composite-types","text":"","title":"Composite Types"},{"location":"#pair","text":"(cons :expr :expr) The pair , also known as cons cell, is the basic Scheme compound data type. It is simply a grouping of two values of any types (2-tuple); the first and second values are sometimes referred to respectively as the car and cdr . Evaluation Rule: pair values are evaluated by procedure application, however, only pair values which are list \u2019s can be properly applied; evaluating a non-list pair raises an error.","title":"pair"},{"location":"#list","text":"; code (:callable :expr ...) ; data () (cons :expr (cons ())) (list :expr ...) A list value is either the empty list () , or ordered pair \u2019s terminated by () , where the car of the pair is an element of the list, and the cdr is the rest of the list. Scheme data and code are both represented as lists, which makes meta-programming easy and fun. See Quoting and Evaluation and Macro Definition . Evaluation Rule: The first value of the list is applied (called) with the rest of the list as arguments. If the first value of the list is not callable , an error is raised. Exception: the empty list () is not applied, it evaluates to itself. See Function Definition .","title":"list"},{"location":"#special-types","text":"","title":"Special Types"},{"location":"#quote","text":"(quote :expr) 'expr Any expression can be quoted, using either the quote form or a starting apostrophe ' . Evaluation Rule: A quoted expression evaluates to the expression. This is useful to prevent symbol binding and procedure application. See Quoting and Evaluation .","title":"quote"},{"location":"#error","text":"(error type \"some-message\") Error values do no inherently do anything, until they are raise \u2019d as exceptions. See Exceptions . Evaluation Rule: An error value evaluates to itself.","title":"error"},{"location":"#callable-types","text":"","title":"Callable Types"},{"location":"#lambda","text":"(fn params :expr ...) See Function Definition . Evaluation Rule: A lambda value evaluates to itself. It is applied when it is the first element of a list .","title":"lambda"},{"location":"#procmacro","text":"(macro params :expr ...) Procedural macros. See Macro Definition . Evaluation Rule: A procmacro value evaluates to itself. It is applied when it is the first element of a list .","title":"procmacro"},{"location":"#builtin-callable-types","text":"","title":"Builtin Callable Types"},{"location":"#function","text":"; not constructable Opaque type containing a builtin function. Evaluation Rule: A function value evaluates to itself. It is applied when it is the first element of a list .","title":"function"},{"location":"#specialform","text":"; not constructable Opaque type containing a builtin macro. Evaluation Rule: A specialform value evaluates to itself. It is applied when it is the first element of a list .","title":"specialform"},{"location":"#forms","text":"","title":"Forms"},{"location":"#binding-and-assignment","text":"","title":"Binding and Assignment"},{"location":"#def","text":"(def name :expr) Create and assign binding in local scope.","title":"def"},{"location":"#set","text":"(set! name :expr) Change existing binding. Raises error if a binding does not already exists.","title":"set!"},{"location":"#let","text":"(let name value:expr :expr ...) Create a binding in a new local scope. ; Example >>> (let x 12 (display x)) 12","title":"let"},{"location":"#lets","text":"(lets ((name value:expr) ...) :expr ...) Create multiple bindings in a new local scope. ; Example >>> (lets ((x 5) (y 7)) ... (display x) ... (display y)) 5 7","title":"lets"},{"location":"#defglobal","text":"(defglobal name :expr) Create and assign binding in global env.","title":"defglobal"},{"location":"#setglobal","text":"(setglobal! name :expr) Change existing binding in global env. Raises error if a binding does not already exists.","title":"setglobal!"},{"location":"#function-definition","text":"","title":"Function Definition"},{"location":"#defn","text":"(defn name parameters :expr ...) Create lambda function and bind it to name . Variadic lambdas can be defined with formal parameters like (x . xs) - there must be a single parameter after . , which will be a list containing zero or more arguments depending on the number of arguments passed. ; Example >>> (defn increment (x) (+ x 1)) >>> (increment 1) 2 >>> (defn variadic (x y . rest) rest) >>> (variadic 1) Unhandled ApplyError \"expected at least 2 argument(s)\" >>> (variadic 1 2) () >>> (variadic 1 2 3 4) (3 4)","title":"defn"},{"location":"#fn","text":"(fn parameters :expr ...) Create a lambda (function). See defn .","title":"fn"},{"location":"#control-flow","text":"","title":"Control Flow"},{"location":"#if","text":"(if predicate:bool then:expr else:expr) Evaluates only then or else conditonally on the value of predicate .","title":"if"},{"location":"#begin","text":"(begin :expr ...) Evaluate expressions sequentially and return value of last expression.","title":"begin"},{"location":"#comparison","text":"","title":"Comparison"},{"location":"#eq","text":"(eq? :expr :expr) Identity comparison. Check if two values are the same object.","title":"eq?"},{"location":"#equal","text":"(equal? :expr :expr) Value comparison. Check if two values are equal.","title":"equal?"},{"location":"#logical-operators","text":"","title":"Logical Operators"},{"location":"#not","text":"(not :bool)","title":"not"},{"location":"#pair-and-list-operations","text":"","title":"Pair and List Operations"},{"location":"#cons","text":"(cons left:expr right:expr) Construct a pair.","title":"cons"},{"location":"#car","text":"(car :pair) Get first item of a pair (head of list).","title":"car"},{"location":"#cdr","text":"(cdr :pair) Get second item of a pair (rest of list).","title":"cdr"},{"location":"#list_1","text":"(list :expr ...) Construct a list, which is a linked list made from pairs and terminated by nil . ; Example >>> (equal? (list 1 2 3) (cons 1 (cons 2 (cons 3 nil)))) true >>> (equal? (list 1 2 3) (cons 1 (list 2 3)))","title":"list"},{"location":"#empty","text":"(empty? :expr) Check if value is the empty list (nil).","title":"empty?"},{"location":"#list_2","text":"(list? :expr) Check if value is a nil-terminated list of ordered pairs.","title":"list?"},{"location":"#map","text":"(map f:procedure vals:list) Applies f to each value in a list and return results in list. ; Example >>> (map (fn (x) (* 2 x)) (list 1 2 3)) (2 4 6)","title":"map"},{"location":"#fold","text":"(fold f:procedure init:expr vals:list) Applies f to each value in a list and accumulate results in init . ; Example >>> (fold + 0 (list 1 2 3)) 6 >>> (fold cons () (list 1 2 3)) (3 2 1)","title":"fold"},{"location":"#range","text":"(range from:integer to:integer) Produce list of integers for range [ from , to ), where to >= from .","title":"range"},{"location":"#string-operations","text":"","title":"String Operations"},{"location":"#concat","text":"(concat :string ...) Concatenate multiple strings. ; Example >>> (concat \"foo\" \"bar\" \"baz\") \"foobarbaz\"","title":"concat"},{"location":"#integer-operations","text":"","title":"Integer Operations"},{"location":"#_1","text":"(+ :integer ...)","title":"+"},{"location":"#-","text":"(- :integer ...)","title":"-"},{"location":"#_2","text":"(* :integer ...)","title":"*"},{"location":"#_3","text":"(/ :integer ...)","title":"/"},{"location":"#printing","text":"","title":"Printing"},{"location":"#print","text":"(print :string)","title":"print"},{"location":"#repr","text":"(repr :expr) Get string representation of a value.","title":"repr"},{"location":"#display","text":"(display :expr) Print string representation of a value.","title":"display"},{"location":"#modules","text":"(Work in progress.) jibi has a basic namespaced module system. A module is simply a .jibi file. They provide no privacy, all variables defined in the module scope are accessible to importers. Module files are only evaluated once, re-importing gets a reference to the existing module. At the moment only the current working directory is searched to find modules, thus importing \u201cstl/unittest\u201d looks for the file ./stl/unittest.jibi'.","title":"Modules"},{"location":"#import","text":"(import module:string as name) Import module and bind it to name . ; Example >>> (import \"stl/math\" as math) >>> (math::product (list 2 3 4)) 24","title":"import"},{"location":"#use","text":"(use module:symbol name ...) Bind a name from a module into the global scope. ; Example >>> (import \"stl/math\" as math) >>> (use math product sum) >>> (product (list 2 3 4)) 24","title":"use"},{"location":"#import-from","text":"(import-from module:string name ...) Import specific names from a module. ; Example >>> (import-from \"stl/math\" product sum) >>> (sum (list 2 3 4)) 9 >>> (product (list 2 3 4)) 24","title":"import-from"},{"location":"#type-inspection","text":"","title":"Type Inspection"},{"location":"#type","text":"(type :expr) Inspect type of a value. ; Example >>> (type \"foo\") string","title":"type"},{"location":"#type_1","text":"(type? :expr type) (string? :expr) (symbol? :expr) ... Test type of a value. There are also convenience functions for every type. ; Example >>> (type? \"foo\" string) true >>> (integer? \"foo\") false","title":"type?"},{"location":"#quoting-and-evaluation","text":"","title":"Quoting and Evaluation"},{"location":"#quote_1","text":"(quote :expr) A quoted expression evaluates to the expression. ; Example >>> (def a 100) >>> a 100 >>> (quote a) a >>> (+ 5 5) 10 >>> (quote (+ 5 5)) (+ 5 5)","title":"quote"},{"location":"#eval","text":"(eval :expr) Evaluate an expression. ; Example >>> (def expr (quote (+ 5 5))) >>> expr (+ 5 5) >>> (eval expr) 10","title":"eval"},{"location":"#evalfile","text":"(evalfile filename:string) Evaluate file in the global environment.","title":"evalfile"},{"location":"#apply","text":"(apply :procedure :list) Apply a procedure to a list of arguments. ; Example >>> (apply + (list 1 2 3)) 6","title":"apply"},{"location":"#macro-definition","text":"","title":"Macro Definition"},{"location":"#defmacro","text":"(defmacro name formals :expr ...) jibi macros are \u201cprocedural\u201d; they are simply lambdas which return code. The body of the macro is first evaluated in the macro\u2019s lexical environment. Then the resulting expression is evaluated in the caller\u2019s environment. Beware of capturing variables from the macro\u2019s environment; if you want to refer to variables in the invocation environment, use quotation. This add-x macro captures the global binding for x : >>> (defmacro add-x (y) (list + x y)) >>> (def x 100) >>> (add-x 5) 105 >>> (set! x 200) >>> (add-x 5) 205 >>> ((fn (x) (add-x 5)) 1000) 205 In this version, x is not captured; the value of x is taken from the local scope where the macro is called: >>> (def x 100) >>> (defmacro add-x (y) (list + 'x y)) >>> ((fn (x) (add-x 5)) 1000) 1005","title":"defmacro"},{"location":"#macro","text":"(macro formals :expr ...) Create macro. See \u2018defmacro\u2019 .","title":"macro"},{"location":"#exceptions","text":"Errors can be raised to interrupt program flow, and can be caught with the try form.","title":"Exceptions"},{"location":"#error_1","text":"(error type:symbol reason:string) Create error with custom type.","title":"error"},{"location":"#exception","text":"(exception reason:string) Create error of type Exception.","title":"exception"},{"location":"#raise","text":"(raise :error) Raise an error (can be any error type, not just Exception).","title":"raise"},{"location":"#try","text":"(try body:expr catch:expr) Try evaluating body . If an error is raised, evaluate catch ; the raised error value is bound to err when catch is evaluated. ; Example >>> (defn errored () ... (raise (exception \"oh no!\")) ... (print \"never evaluated\")) >>> (errored) Unhandled Error: oh no! >>> (try (print \"no error\") (print (concat \"handled \" (repr err)))) no error >>> (try (errored) (print (concat \"handled \" (repr err)))) handled #[error Exception \"oh no!\"]","title":"try"},{"location":"#assert","text":"(assert predicate:bool) Raises an exception if predicate is false.","title":"assert"},{"location":"#environment-procedures","text":"","title":"Environment Procedures"},{"location":"#env","text":"(env) Get the nearest enclosing environment (most local scope).","title":"env"},{"location":"#env-lookup","text":"(env-lookup :env :symbol) Look up symbol in the given environment.","title":"env-lookup"},{"location":"#env-def","text":"(env-def :env :symbol :expr) Define symbol in the given environment.","title":"env-def"},{"location":"#env-set","text":"(env-set! :env :symbol :expr) Set symbol in the given environment.","title":"env-set"},{"location":"#env-parent","text":"(env-parent :env) Get parent env, or nil if there is no parent env.","title":"env-parent"},{"location":"#env-globals","text":"(env-globals) Get the global environment.","title":"env-globals"},{"location":"#system-procedures","text":"","title":"System Procedures"},{"location":"#environment-variable","text":"(environment-variable var:string) Get value of environment variable. Raises exception if the variable is not set or contains non-UTF8 characters.","title":"environment-variable"},{"location":"#exit","text":"(exit :integer) Exit program with a status code.","title":"exit"},{"location":"#debugging","text":"","title":"Debugging"},{"location":"#dd","text":"(dd :expr) Print Rust struct debug.","title":"dd"},{"location":"#ddp","text":"(ddp :expr) Pretty print Rust struct debug.","title":"ddp"},{"location":"#dda","text":"(dda :expr) Print pointer address.","title":"dda"},{"location":"#ddc","text":"(ddc :lambda|:procmacro) Print code of (non-builtin) lambda or macro.","title":"ddc"},{"location":"#ddm","text":"(ddm :procmacro :expr ...) Print code generated by a procmacro for the given arguments.","title":"ddm"},{"location":"#standard-library-stl","text":"I hope you were not expecting a real standard library. You can have some unit testing utilities for consolation.","title":"Standard Library (STL)"},{"location":"#stlunittest","text":"Write and run unit tests with assertions.","title":"stl/unittest"},{"location":"#test","text":"(test name:string :expr ...) A test is simply one or more expressions. It is considered a success if no exceptions are raised when the body of the test is evaluated.","title":"test"},{"location":"#test-suite","text":"(test-suite name:string (test ...) ...) Execute a series of tests, print a summary of the results, and raise an error if any of the tests failed. Set the environment variable TEST_VERBOSE to 1 to print more details. ; sometests.jibi (import-from \"stl/unittest\" test test-suite assert-equal) (test-suite \"very useful tests\" (test \"correct\" (assert-equal true true)) (test \"suspicious\" (assert-equal true false))) $ jibi sometests.jibi Testing very useful tests... suspicious: failed (#[error Exception: true is not equal to false]) Test results: 1 ok, 1 failed Traceback: ... Exception: Some tests failed.","title":"test-suite"},{"location":"#assert-not","text":"(assert-not :bool) Check if false.","title":"assert-not"},{"location":"#assert-eq","text":"(assert-eq :expr :expr) Check (identity) equality.","title":"assert-eq"},{"location":"#assert-equal","text":"(assert-equal :expr :expr) Check (value) equality.","title":"assert-equal"},{"location":"#assert-type","text":"(assert-type :expr type) Check type of expression.","title":"assert-type"},{"location":"#assert-raise","text":"(assert-raise :expr) Check that the given expression raises an error when evaluated.","title":"assert-raise"}]}